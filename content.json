{"meta":{"title":"Jeongwook, Life Blog","subtitle":"배움과 생각 쌓기","description":"Jeongwook Kim's Private Space","author":"Jeongwook, Kim","url":"http://jeongwookie.github.io"},"pages":[],"posts":[{"title":"네이버 api 연동하여 데이터 추출하기","slug":"collect-data-using-naver-search-api","date":"2019-03-20T02:17:11.000Z","updated":"2019-03-20T13:23:04.008Z","comments":true,"path":"2019/03/20/collect-data-using-naver-search-api/","link":"","permalink":"http://jeongwookie.github.io/2019/03/20/collect-data-using-naver-search-api/","excerpt":"","text":"이번 포스트는 네이버 개발자 센터에서 제공하는 검색 api를 통해 우리가 원하는 키워드를 검색하고, 그 결과를 json파일로 저장하는 것을 다루어보겠다. json파일로 저장하는 이유는 pandas와 같은 데이터 분석 툴을 사용할 때, import하기 좋은 파일 형식이기 때문이다. 아래와 같은 순서로 진행한다. Step 1: 네이버 개발자센터 등록 및 키 값 받아오기 Step 2: api caller 만들기 Step 3: 데이터 수집 후 json 파일로 저장하기 Step 4: pandas 사용하여 분석하기 Step 1. 네이버 개발자센터 등록 및 키 값 받아오기먼저 네이버 개발자 센터에 접속하여 Application -&gt; 애플리케이션 등록 을 클릭한다. 아래와 같은 화면이 뜨는데, 검색 api 누르고 안드로이드 설정에서 적당한 이름을 넣으면 된다. (com.블라블라) 완료하게 되면, 애플리케이션 정보에 client ID와 client secret 코드가 보이는데 이걸 어딘가 안전한 곳에 복사해둔다. (노출 절대 금지) Step 2. api caller 만들기이제, 네이버 검색 api를 불러올 caller 을 만들어 보자. 아까 전 네이버 개발자 센터 홈페이지에서 Documents -&gt; 서비스 API -&gt; 검색을 누르면 아래와 같은 페이지가 뜬다. 코드는 python으로 클릭. 여기 있는 코드를 긁어서 오면 아래와 같다. 중간에 YOUR_CLIENT_ID와 YOUR_CLIENT_SECRET에는 아까 복사해 두었던 키값들을 기입한다. 1234567891011121314151617181920#&nbsp;네이버&nbsp;검색&nbsp;API예제는&nbsp;블로그를&nbsp;비롯&nbsp;전문자료까지&nbsp;호출방법이&nbsp;동일하므로&nbsp;blog검색만&nbsp;대표로&nbsp;예제를&nbsp;올렸습니다.#&nbsp;네이버&nbsp;검색&nbsp;Open&nbsp;API&nbsp;예제&nbsp;-&nbsp;블로그&nbsp;검색import&nbsp;osimport&nbsp;sysimport&nbsp;urllib.requestclient_id&nbsp;=&nbsp;“YOUR_CLIENT_ID”client_secret&nbsp;=&nbsp;“YOUR_CLIENT_SECRET”encText&nbsp;=&nbsp;urllib.parse.quote(“검색할&nbsp;단어”)url&nbsp;=&nbsp;“https://openapi.naver.com/v1/search/blog?query=&quot;&nbsp;+&nbsp;encText&nbsp;#&nbsp;json&nbsp;결과#&nbsp;url&nbsp;=&nbsp;”https://openapi.naver.com/v1/search/blog.xml?query=&quot;&nbsp;+&nbsp;encText&nbsp;#&nbsp;xml&nbsp;결과request&nbsp;=&nbsp;urllib.request.Request(url)request.add_header(“X-Naver-Client-Id”,client_id)request.add_header(“X-Naver-Client-Secret”,client_secret)response&nbsp;=&nbsp;urllib.request.urlopen(request)rescode&nbsp;=&nbsp;response.getcode()if(rescode==200):&nbsp;&nbsp;&nbsp;&nbsp;response_body&nbsp;=&nbsp;response.read()&nbsp;&nbsp;&nbsp;&nbsp;print(response_body.decode(‘utf-8’))else:&nbsp;&nbsp;&nbsp;&nbsp;print(“Error&nbsp;Code:”&nbsp;+&nbsp;rescode)Colored by Color Scriptercs 샘플 코드의 주석에 적힌 대로, 현재 이 코드는 키워드를 받아서 블로그를 검색한 결과를 보여준다. 코드가 너무 기니까 조금 간략하게 바꾸어 보자. 대충 이런 식이다. 1234567891011import&nbsp;requestsfrom&nbsp;urllib.parse&nbsp;import&nbsp;urlparse&nbsp;keyword&nbsp;=&nbsp;“”url&nbsp;=&nbsp;“https://openapi.naver.com/v1/search/blog?query=&quot;&nbsp;+&nbsp;keywordresult&nbsp;=&nbsp;requests.get(urlparse(url).geturl(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers={“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”})json_obj&nbsp;=&nbsp;result.json()print(json_obj)&nbsp;Colored by Color Scriptercs 위 코드는 keyword 를 받아서 네이버 검색 api를 거친 후 json_obj를 반환한다. 이제 call을 하는 함수를 만들어 보자. 키워드를 입력한 후, 그 검색 결과를 한번에 100개씩 받아오는 함수를 작성한다. 1234567891011import&nbsp;requestsfrom&nbsp;urllib.parse&nbsp;import&nbsp;quote&nbsp;def&nbsp;call(keyword,&nbsp;start):&nbsp;&nbsp;&nbsp;&nbsp;encText&nbsp;=&nbsp;quote(keyword)&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;“https://openapi.naver.com/v1/search/blog?query=&quot;&nbsp;+&nbsp;encText&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;“&amp;display=100”&nbsp;+&nbsp;“&amp;start=”&nbsp;+&nbsp;str(start)&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;requests.get(url=url,&nbsp;headers={“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”})&nbsp;&nbsp;&nbsp;&nbsp;print(result)&nbsp;&nbsp;#&nbsp;Response&nbsp;[200]&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result.json()Colored by Color Scriptercs &amp;display=100은 한번에 100개의 검색 결과를 보여준다는 것이고, &amp;start=은 그 뒤의 숫자에 따라 어느 순서의 검색 결과부터 출력하는지를 결정한다. 뒤의 숫자는 그냥 두면 int 속성을 가지게 되므로, str()을 사용하여 string으로 바꾸어 url을 완성시킨다. Step 3. 데이터 수집 후 json 파일로 저장하기이제, 검색 결과를 한번에 1000개 수집하여 json 파일로 저장해 보자. 모듈화를 위해 libs 폴더 내 naver_api_call 폴더를 만들고, 그 내부에 먼저 api_caller.py 파일을 만들어 작성하였다. 123456789101112131415161718192021#&nbsp;api_caller.py&nbsp;import&nbsp;requestsfrom&nbsp;urllib.parse&nbsp;import&nbsp;quote&nbsp;#&nbsp;네이버&nbsp;api&nbsp;calldef&nbsp;call(keyword,&nbsp;start):&nbsp;&nbsp;&nbsp;&nbsp;encText&nbsp;=&nbsp;quote(keyword)&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;“https://openapi.naver.com/v1/search/blog?query=&quot;&nbsp;+&nbsp;encText&nbsp;+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“&amp;display=100”&nbsp;+&nbsp;“&amp;start=”&nbsp;+&nbsp;str(start)&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;requests.get(url=url,&nbsp;headers={“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”})&nbsp;&nbsp;&nbsp;&nbsp;print(result)&nbsp;&nbsp;#&nbsp;Response&nbsp;[200]&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result.json()&nbsp;#&nbsp;1000개의&nbsp;검색&nbsp;결과&nbsp;받아오기def&nbsp;get1000results(keyword):&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;num&nbsp;in&nbsp;range(0,10):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;list&nbsp;+&nbsp;call(keyword,&nbsp;num&nbsp;*&nbsp;100&nbsp;+&nbsp;1)[‘items’]&nbsp;#&nbsp;list&nbsp;안에&nbsp;키값이&nbsp;’item’인&nbsp;애들만&nbsp;넣기&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;listColored by Color Scriptercs 함수들을 만들었으니, 이제 실제로 사용해 보자. 우리가 할 일은 네이버 api call을 하고, 1000개의 키워드 검색 결과를 받아온 후, 이를 json파일에 저장하는 것이다. 12345678910111213#&nbsp;01_collect.py&nbsp;from&nbsp;libs.naver_api_call.api_caller&nbsp;import&nbsp;get1000resultsimport&nbsp;json&nbsp;list&nbsp;=&nbsp;[]result&nbsp;=&nbsp;get1000results(“강남역&nbsp;맛집”)result_2&nbsp;=&nbsp;get1000results(“강남역&nbsp;찻집”)list&nbsp;=&nbsp;list&nbsp;+&nbsp;result&nbsp;+&nbsp;result_2&nbsp;file&nbsp;=&nbsp;open(“./gangnam.json”,&nbsp;“w+”)&nbsp;&nbsp;#&nbsp;gangnam.json&nbsp;파일을&nbsp;쓰기&nbsp;가능한&nbsp;상태로&nbsp;열기&nbsp;(만들기)file.write(json.dumps(list))&nbsp;&nbsp;#&nbsp;쓰기&nbsp;Colored by Color Scriptercs 위 코드를 출력하면 정상적으로 gangnam.json이 디렉토리에 생성됨을 확인할 수 있다. Step 4. pandas 사용하여 분석하기pandas는 여러가지 분석에 유용한 함수들을 제공하여, 길고 긴 json 파일을 보다 쉽고 빠르게 파악할 수 있도록 돕는다. 123456789101112#&nbsp;02_analyze_pd.py&nbsp;import&nbsp;pandas&nbsp;as&nbsp;pd&nbsp;df&nbsp;=&nbsp;pd.read_json(“./gangnam.json”)print(df.count())&nbsp;&nbsp;#&nbsp;각&nbsp;key&nbsp;별&nbsp;숫자&nbsp;출력&nbsp;df_sum&nbsp;=&nbsp;df.groupby(“bloggername”).count()&nbsp;&nbsp;#&nbsp;groupby()&nbsp;함수를&nbsp;사용하여&nbsp;bloggername별로&nbsp;출력print(df_sum)&nbsp;bloggernames&nbsp;=&nbsp;df[‘bloggername’]&nbsp;&nbsp;#&nbsp;bloggername&nbsp;만&nbsp;출력print(bloggernames)Colored by Color Scriptercs count() 는 json 파일에 저장된 각각의 key값에 대한 데이터 숫자를 세어준다. 우리는 위에서 “강남역 맛집”으로 검색한 결과 1000개, 그리고 “강남역 찻집”으로 검색한 결과 1000개로 총 2000개의 결과값을 저장해 두었었다. groupby() 는 지정한 key값으로 결과값을 그룹화하여 보여준다. 결과값을 보면 어떤 bloggername을 가진 사람이 우리가 지정한 키워드에 대해서 블로깅을 많이 하였는지 알 수 있다. 세 번째 출력값은 현재 저장된 json 파일에서 bloggername 을 전부 출력해 본 것이다. 총 1640개의 블로그가 수집되었음을 알 수 있다. 위 포스트는 Kyeongrok Kim님의 네이버 api 불러오기 예시를 실습해보고, 이를 간단히 정리한 것임을 밝힙니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"},{"name":"크롤링","slug":"크롤링","permalink":"http://jeongwookie.github.io/tags/크롤링/"},{"name":"데이터 마이닝","slug":"데이터-마이닝","permalink":"http://jeongwookie.github.io/tags/데이터-마이닝/"}]},{"title":"네이버 금융에서 주식 가격 크롤링하기","slug":"naver-finance-data-crawling-using-python","date":"2019-03-18T01:36:15.000Z","updated":"2019-03-18T09:17:28.000Z","comments":true,"path":"2019/03/18/naver-finance-data-crawling-using-python/","link":"","permalink":"http://jeongwookie.github.io/2019/03/18/naver-finance-data-crawling-using-python/","excerpt":"","text":"19년 3월부터 카이스트 데이터사이언스 연구실 (KAIST DS LAB)에서 일하기 시작했다. 가장 처음 맡은 일이 파이썬으로 특정 데이터들을 웹에서 크롤링하는 것인데, 예전에 BeautlfulSoup4으로 간단하게 몇 가지 다루어 본 것을 복습하는 겸 포스트를 작성하기로 했다. 기본적으로 작업은 파이참 (pyCharm)으로 진행했다. 네이버 금융 웹에서 봉차트 데이터 수집하기아래와 같은 순서로 진행한다. Step 1: 특정 종목의 가격 받아오기 Step 2: 여러 종목의 가격 받아오기 Step 3: 특정 종목의 봉차트 데이터 받아오기 Step 4: 여러 종목의 봉차트 데이터 받아오기 시작하기 전, interpreter가 제대로 설치되어 있는지 체크하자. 우리가 이번에 사용할 패키지는 requests 와 beautifulsoup4이다. 맥에서는 preference -&gt; project interpreter에 가면 다운로드 및 확인이 가능하고, 윈도우에서는 file -&gt; setting -&gt; project interpreter에 가면 마찬가지로 확인이 가능하다. 맥에서 파이참 preference을 열었을 때 Step 1. 특정 종목의 가격 받아오기요즘 펄어비스가 신작을 발표하면서 주식 가격이 떡상(?)하고 있다. 개인적으로 관심이 가는 회사니까.. 여기 데이터를 한번 가져와 보자. 먼저 네이버 금융에 접속해서 펄어비스를 검색해 보자. 빨간색 네모가 우리가 가져가고 싶은 데이터 저 빨간색 네모 안의 숫자가 우리가 크롤링 하고 싶은 펄어버스 주식의 현재 가격이다. 크롬 (chrome)의 개발자 도구를 켜서 위치를 확인하자. 이제 코드를 짜면 된다. 123456789101112import&nbsp;requestsfrom&nbsp;bs4&nbsp;import&nbsp;BeautifulSoup&nbsp;url&nbsp;=&nbsp;“https://finance.naver.com/item/main.nhn?code=263750&quot;result&nbsp;=&nbsp;requests.get(url)bs_obj&nbsp;=&nbsp;BeautifulSoup(result.content,&nbsp;“html.parser”)&nbsp;no_today&nbsp;=&nbsp;bs_obj.find(“p”,&nbsp;{“class”:&nbsp;“no_today”})&nbsp;#&nbsp;태그&nbsp;p,&nbsp;속성값&nbsp;no_today&nbsp;찾기blind&nbsp;=&nbsp;no_today.find(“span”,&nbsp;{“class”:&nbsp;“blind”})&nbsp;#&nbsp;태그&nbsp;span,&nbsp;속성값&nbsp;blind&nbsp;찾기now_price&nbsp;=&nbsp;blind.text&nbsp;print(now_price)Colored by Color Scriptercs 실행하면 now_price가 187,500이 제대로 출력됨을 확인할 수 있다.(실시간으로 가격 변동이 발생 ㅠㅠ) Step 2. 여러 종목의 가격 받아오기자세히 보면, 우리가 입력한 url의 제일 뒤 숫자 6자리가 회사 코드임을 알 수 있다. 이를 원하는 코드로 바꿈으로써, 여러 회사들의 주식 가격을 가져올 수 있다. 위 코드에 대해서 company_code를 입력하면 now_price를 출력할 수 있도록 리팩토링 (refactoring) 해보자. 1234567891011121314151617181920212223242526import&nbsp;requestsfrom&nbsp;bs4&nbsp;import&nbsp;BeautifulSoup&nbsp;#&nbsp;company_code를&nbsp;입력받아&nbsp;bs_obj를&nbsp;출력def&nbsp;get_bs_obj(company_code):&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;“https://finance.naver.com/item/main.nhn?code=&quot;&nbsp;+&nbsp;company_code&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;requests.get(url)&nbsp;&nbsp;&nbsp;&nbsp;bs_obj&nbsp;=&nbsp;BeautifulSoup(result.content,&nbsp;“html.parser”)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bs_obj&nbsp;#&nbsp;company_code를&nbsp;입력받아&nbsp;now_price를&nbsp;출력def&nbsp;get_price(company_code):&nbsp;&nbsp;&nbsp;&nbsp;bs_obj&nbsp;=&nbsp;get_bs_obj(company_code)&nbsp;&nbsp;&nbsp;&nbsp;no_today&nbsp;=&nbsp;bs_obj.find(“p”,&nbsp;{“class”:&nbsp;“no_today”})&nbsp;&nbsp;&nbsp;&nbsp;blind&nbsp;=&nbsp;no_today.find(“span”,&nbsp;{“class”:&nbsp;“blind”})&nbsp;&nbsp;&nbsp;&nbsp;now_price&nbsp;=&nbsp;blind.text&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;now_price&nbsp;#&nbsp;펄어비스&nbsp;회사&nbsp;코드는&nbsp;”263750”#&nbsp;삼성전자&nbsp;회사&nbsp;코드는&nbsp;”005930”#&nbsp;셀트리온&nbsp;회사&nbsp;코드는&nbsp;”068270”company_codes&nbsp;=&nbsp;[“263750”,&nbsp;“005930”,&nbsp;“068270”]&nbsp;for&nbsp;item&nbsp;in&nbsp;company_codes:&nbsp;&nbsp;&nbsp;&nbsp;now_price&nbsp;=&nbsp;get_price(item)&nbsp;&nbsp;&nbsp;&nbsp;print(now_price)Colored by Color Scriptercs 실행하면, 펄어비스와 삼성전자, 그리고 셀트리온의 현재 주식 가격을 잘 받아오고 있음을 확인할 수 있다. Step 3. 특정 종목의 봉차트 데이터 받아오기이번에는 펄어비스의 전일, 고가, 시가, 저가 주식 데이터를 가져와 보자. 아까와 마찬가지로 먼저 데이터의 위치를 개발자 도구를 사용하여 알아보자. 빨간색 네모 안에 전일 주식 가격이 들어있음을 확인한 후, 코드를 짜보자. 123456789101112import&nbsp;requestsfrom&nbsp;bs4&nbsp;import&nbsp;BeautifulSoup&nbsp;url&nbsp;=&nbsp;“https://finance.naver.com/item/main.nhn?code=263750&quot;result&nbsp;=&nbsp;requests.get(url)bs_obj&nbsp;=&nbsp;BeautifulSoup(result.content,&nbsp;“html.parser”)&nbsp;td_first&nbsp;=&nbsp;bs_obj.find(“td”,&nbsp;{“class”:&nbsp;“first”})&nbsp;&nbsp;#&nbsp;태그&nbsp;td,&nbsp;속성값&nbsp;first&nbsp;찾기blind&nbsp;=&nbsp;td_first.find(“span”,&nbsp;{“class”:&nbsp;“blind”})&nbsp;&nbsp;#&nbsp;태그&nbsp;span,&nbsp;속성값&nbsp;blind&nbsp;찾기close&nbsp;=&nbsp;blind.text&nbsp;print(close)Colored by Color Scriptercs 전일 (close)에 해당하는 펄어비스의 주식 가격이 제대로 출력되고 있다. 위와 같은 방법으로, 고가 (high), 시가 (open), 저가 (low)에 대한 데이터의 위치를 찾아서 코딩하면 된다. 주의할 점은, find() 함수는 가장 처음 만나는 태그를 반환하므로, 그 뒤의 동일한 이름의 태그를 찾고 싶다면 find_all() 함수를 사용해야 한다. 또한, find_all()은 리스트 (list)를 반환한다. 대략적으로 각 데이터의 위치를 아래에 그려 보았다. tr 태그가 두 개, 그리고 각각의 태그 안에 td 태그가 세 개씩 있고, 첫 번째 td는 다행히도 속성값이 명시되어 있지만 두 번째 td부터는 그렇지 않다. 위와 같은 형태일 때는 모두를 포함하면서 속성값을 가지고 있어, 전체 데이터에서 특정지을 수 있는 태그부터 찾아서 narrow down해야 한다. 이번에는 그 역할로 table 태그의 속성값 no_info를 사용할 것이다. 12345678910111213141516171819202122232425262728293031323334import&nbsp;requestsfrom&nbsp;bs4&nbsp;import&nbsp;BeautifulSoup&nbsp;url&nbsp;=&nbsp;“https://finance.naver.com/item/main.nhn?code=263750&quot;result&nbsp;=&nbsp;requests.get(url)bs_obj&nbsp;=&nbsp;BeautifulSoup(result.content,&nbsp;“html.parser”)&nbsp;#close&nbsp;종가(전일)td_first&nbsp;=&nbsp;bs_obj.find(“td”,&nbsp;{“class”:&nbsp;“first”})&nbsp;&nbsp;#&nbsp;태그&nbsp;td,&nbsp;속성값&nbsp;first&nbsp;찾기blind&nbsp;=&nbsp;td_first.find(“span”,&nbsp;{“class”:&nbsp;“blind”})&nbsp;&nbsp;#&nbsp;태그&nbsp;span,&nbsp;속성값&nbsp;blind&nbsp;찾기close&nbsp;=&nbsp;blind.text&nbsp;#&nbsp;high&nbsp;고가table&nbsp;=&nbsp;bs_obj.find(“table”,&nbsp;{“class”:&nbsp;“no_info”})&nbsp;&nbsp;#&nbsp;태그&nbsp;table,&nbsp;속성값&nbsp;no_info&nbsp;찾기trs&nbsp;=&nbsp;table.find_all(“tr”)&nbsp;&nbsp;#&nbsp;tr을&nbsp;list로&nbsp;[]first_tr&nbsp;=&nbsp;trs[0]&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;tr&nbsp;지정tds&nbsp;=&nbsp;first_tr.find_all(“td”)&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;tr&nbsp;안에서&nbsp;td를&nbsp;list로second_tds&nbsp;=&nbsp;tds[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;td&nbsp;지정high&nbsp;=&nbsp;second_tds.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;#&nbsp;open&nbsp;시가second_tr&nbsp;=&nbsp;trs[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;tr&nbsp;지정tds_second_tr&nbsp;=&nbsp;second_tr.find_all(“td”)&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;tr&nbsp;안에서&nbsp;td를&nbsp;list로first_td_in_second_tr&nbsp;=&nbsp;tds_second_tr[0]&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;td&nbsp;지정open&nbsp;=&nbsp;first_td_in_second_tr.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;#&nbsp;low&nbsp;저가second_td_in_second_tr&nbsp;=&nbsp;tds_second_tr[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;td&nbsp;지정low&nbsp;=&nbsp;second_td_in_second_tr.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;print(close)print(high)print(open)print(low)Colored by Color Scriptercs 위 코드를 실행시키면, 펄어비스의 봉차트 주식 데이터가 제대로 출력됨을 확인할 수 있다. Step 4. 여러 종목의 봉차트 데이터 받아오기이제 위 코드에 대해서 company_code를 입력하면 봉차트 데이터를 출력할 수 있도록 리팩토링 (refactoring) 해보자. 입력값은 company_code이고, 리턴값은 close, high, open, low인 함수를 짜면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import&nbsp;requestsfrom&nbsp;bs4&nbsp;import&nbsp;BeautifulSoup&nbsp;def&nbsp;get_bs_obj(company_code):&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;“https://finance.naver.com/item/main.nhn?code=&quot;&nbsp;+&nbsp;company_code&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;requests.get(url)&nbsp;&nbsp;&nbsp;&nbsp;bs_obj&nbsp;=&nbsp;BeautifulSoup(result.content,&nbsp;“html.parser”)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;bs_obj&nbsp;def&nbsp;get_candle_chart(company_code):&nbsp;&nbsp;&nbsp;&nbsp;bs_obj&nbsp;=&nbsp;get_bs_obj(company_code)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;close&nbsp;종가(전일)&nbsp;&nbsp;&nbsp;&nbsp;td_first&nbsp;=&nbsp;bs_obj.find(“td”,&nbsp;{“class”:&nbsp;“first”})&nbsp;&nbsp;#&nbsp;태그&nbsp;td,&nbsp;속성값&nbsp;first&nbsp;찾기&nbsp;&nbsp;&nbsp;&nbsp;blind&nbsp;=&nbsp;td_first.find(“span”,&nbsp;{“class”:&nbsp;“blind”})&nbsp;&nbsp;#&nbsp;태그&nbsp;span,&nbsp;속성값&nbsp;blind&nbsp;찾기&nbsp;&nbsp;&nbsp;&nbsp;close&nbsp;=&nbsp;blind.text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;high&nbsp;고가&nbsp;&nbsp;&nbsp;&nbsp;table&nbsp;=&nbsp;bs_obj.find(“table”,&nbsp;{“class”:&nbsp;“no_info”})&nbsp;&nbsp;#&nbsp;태그&nbsp;table,&nbsp;속성값&nbsp;no_info&nbsp;찾기&nbsp;&nbsp;&nbsp;&nbsp;trs&nbsp;=&nbsp;table.find_all(“tr”)&nbsp;&nbsp;#&nbsp;tr을&nbsp;list로&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;first_tr&nbsp;=&nbsp;trs[0]&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;tr&nbsp;지정&nbsp;&nbsp;&nbsp;&nbsp;tds&nbsp;=&nbsp;first_tr.find_all(“td”)&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;tr&nbsp;안에서&nbsp;td를&nbsp;list로&nbsp;&nbsp;&nbsp;&nbsp;second_tds&nbsp;=&nbsp;tds[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;td&nbsp;지정&nbsp;&nbsp;&nbsp;&nbsp;high&nbsp;=&nbsp;second_tds.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;open&nbsp;시가&nbsp;&nbsp;&nbsp;&nbsp;second_tr&nbsp;=&nbsp;trs[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;tr&nbsp;지정&nbsp;&nbsp;&nbsp;&nbsp;tds_second_tr&nbsp;=&nbsp;second_tr.find_all(“td”)&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;tr&nbsp;안에서&nbsp;td를&nbsp;list로&nbsp;&nbsp;&nbsp;&nbsp;first_td_in_second_tr&nbsp;=&nbsp;tds_second_tr[0]&nbsp;&nbsp;#&nbsp;첫&nbsp;번째&nbsp;td&nbsp;지정&nbsp;&nbsp;&nbsp;&nbsp;open&nbsp;=&nbsp;first_td_in_second_tr.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;low&nbsp;저가&nbsp;&nbsp;&nbsp;&nbsp;second_td_in_second_tr&nbsp;=&nbsp;tds_second_tr[1]&nbsp;&nbsp;#&nbsp;두&nbsp;번째&nbsp;td&nbsp;지정&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=&nbsp;second_td_in_second_tr.find(“span”,&nbsp;{“class”:&nbsp;“blind”}).text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{“close”:&nbsp;close,&nbsp;“high”:&nbsp;high,&nbsp;“open”:&nbsp;open,&nbsp;“low”:&nbsp;low}&nbsp;#&nbsp;펄어비스&nbsp;회사&nbsp;코드는&nbsp;”263750”#&nbsp;삼성전자&nbsp;회사&nbsp;코드는&nbsp;”005930”#&nbsp;셀트리온&nbsp;회사&nbsp;코드는&nbsp;”068270”company_codes&nbsp;=&nbsp;[“263750”,&nbsp;“005930”,&nbsp;“068270”]&nbsp;for&nbsp;item&nbsp;in&nbsp;company_codes:&nbsp;&nbsp;&nbsp;&nbsp;candle_chart&nbsp;=&nbsp;get_candle_chart(item)&nbsp;&nbsp;&nbsp;&nbsp;print(candle_chart)Colored by Color Scriptercs 위 코드를 실행시키면 펄어비스, 삼성전자, 셀트리온의 주식 봉차트 데이터가 순서대로 출력됨을 확인할 수 있다. 다음 포스트에서는 조금 더 복잡한 데이터 크롤링을 다루어 보겠다. 위 포스트는 Kyeongrok Kim님의 데이터 크롤링 예시를 실습해보고, 이를 간단히 정리한 것임을 밝힙니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"},{"name":"크롤링","slug":"크롤링","permalink":"http://jeongwookie.github.io/tags/크롤링/"},{"name":"데이터 마이닝","slug":"데이터-마이닝","permalink":"http://jeongwookie.github.io/tags/데이터-마이닝/"}]},{"title":"KAIST 창업석사 신입생 모집 (19년 가을)","slug":"kschool-2019-fall-admission","date":"2019-03-14T08:36:59.000Z","updated":"2019-03-18T14:30:00.404Z","comments":true,"path":"2019/03/14/kschool-2019-fall-admission/","link":"","permalink":"http://jeongwookie.github.io/2019/03/14/kschool-2019-fall-admission/","excerpt":"","text":"안녕하세요! 오늘은 제가 다니고 있는 카이스트 창업석사 모집 소식을 들고 찾아왔습니다. 창업석사 자체에 대한 소개글은 이전 포스트인 KAIST 창업석사를 참고해 주세요. 이번에 입학하시는 분들은 k-school 7기 생으로 입학하시는 거에요. (19년 가을학기 시작) 학교에서 하는 오피셜한 설명회가 총 2번 있는데 각각 서울 (3월 27일), 대전 (3월 20일)에서 열립니다. 여기에는 제 선배나 동기분들도 참여하셔서 직접 질의응답을 진행하실 꺼에요. 학교 생활이나 군대 등 궁금하신 부분이 있다면 직접 참여하셔서 물어봐도 좋을 것 같군요. 이번에도 많은 학과들이 창업석사로 학생을 선발하고 있습니다. 참여 학과는 여기 제 주변에도 그렇고, 제 다음으로 입학하신 분들도 수업때 만나 보았었는데요. 학과도 다양하고, 나이대도 다양합니다. 옛날에 카이스트 학부를 졸업하시고 근 10년만에 다시 창업석사로 오신 분도 계십니다 ^^ 그만큼 메리트가 있다는 것이겠죠. 결국 창업의 성패는 같이 하는 사람이 누구인가에 따라 크게 좌우됩니다. 좋은 분들과 만날 기회를 가지고, 같이 공부하고 디스커션 하다 보면 공동 창업자가 되실 분을 만날 수 있지 않을까요? 특히, 현재 전산학부를 베이스로 가지고 계신 분이나, 개발자로 전향하고자 하시는 분들이 주목해야 할 모집 학과를 아래에 정리해 보았습니다. 전산학부 (https://cs.kaist.ac.kr/) 산업및시스템공학과 (http://ie.kaist.ac.kr/) 지식서비스공학대학원 (http://kse.kaist.ac.kr/insiter.php?design_file=1246.php) 문화기술대학원 (https://ct.kaist.ac.kr/main.php?lang=2) 전산학부는 모두 다 아시듯이 전산 전공을 통해서 특화하여 나가실 분이 좋겠지요. 이에 비해 아래 세가지 전공의 대학원들은 개발 능력을 베이스로 실전에 적용하는 분야들이 다른 케이스입니다. 창업석사 선발은 기본적으로 두 가지 기준을 가지고 있는데, 하나가 창업원을 운영하는 K-School이고 나머지 하나는 각 학과 교수님 입니다. 창업원 교수님들의 면접에 통과하셨더라도 학과에서 일반 대학원생을 모집하는 것과 동일한 기준으로 한번 더 시험을 보게 되므로, 각 학과 홈페이지에서 어떤 모집 요강을 가지고 있는지 상세하게 살피시길 바랍니다. 예를 들어, 전산학부는 코딩 테스트를 보고 이를 전공 면접에서 활용하고, 문화기술대학원은 전공과 자기소개와 관련된 ppt를 준비하여야 합니다. 또한 산업및시스템공학과 에서는 필기 시험을 치르는 등 각 학과 별로 모집하는 방법이 다양합니다. 하나의 모집 분야에만 지원이 가능하니, 잘 살펴보시고 본인에게 맞는 선택을 하시길 바랍니다. 선택에 도움이 되시라고 위 전공 분야에서 열린 과목들을 간단하게 아래에 적어봤습니다. (현재 저도 수강중입니다) 산업및시스템공학부: Machine Learning for Knokledge Service 문화기술대학원: Big Data Analysis Using R 지식서비스공학대학원 : Datamining 보시다시피, 기본적으로 전산학부와 유사한 수업들이 열립니다. 코드 쉐어를 하기도 하구요. 하지만, 이런 지식들을 가지고 추구하는 방향이 다르기 때문에 각 학과에서 주요 연구실 홈페이지를 들어가셔서 자신이 관심있는 분야를 서칭하시면 도움이 많이 됩니다. 입학과 관련해서 궁금하신 부분이 있으면 captainfox@kaist.ac.kr로 메일 주세요. 많은 도움은 드리지 못하여도, 제가 아는 선에서 답변 드릴 수 있도록 하겠습니다. 꼭 붙으시길 바랄께요! 19년 가을학기 모집 포스터(상세 내용은 kschool 홈페이지 참고)","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"R을 사용한 데이터 시각화, 2편","slug":"data-visualization-using-R-2","date":"2019-03-08T07:06:15.000Z","updated":"2019-03-17T15:25:46.271Z","comments":true,"path":"2019/03/08/data-visualization-using-R-2/","link":"","permalink":"http://jeongwookie.github.io/2019/03/08/data-visualization-using-R-2/","excerpt":"","text":"지난 포스트 : R을 사용한 데이터 시각화,1편 이번 포스트에서는 내장 데이터셋을 Barplot (막대 그래프) 으로 표현해 볼 것이다. 데이터셋 sleep으로 Barplot 그리기먼저 sleep가 어떤 형태인지부터 보자. 열이 세개로, 각각 extra, group, ID 라는 이름을 가지고 있다. ID는 각각의 사람을 의미하고, group은 실험의 상태를 분류하며, extra는 이에 대한 결과값이다. 이제 x축은 ID, y축은 extra, 그리고 group별로 다른 색상을 나타내는 Barplot을 그려 보자. 1234567head(sleep)attach(sleep) #sleep내의 objects(extra, group, ID)를 이름으로 쉽게 접근가능y &lt;- rbind(extra[1:10], extra[11:20]) #group별로 extra값을 나누어 row bind 시킴. form : numbarplot(y, names.arg = ID[1:10], col = 5:6, xlab = \"ID\", ylab = \"Extra Sleep Hour\", beside = T)# beside는 논리값으로, True이면 값을 병렬적으로, False이면 값을 쌓아서 반환함abline(h=0) #높이가 0인 line을 덧그림legend('topleft', title = 'group', legend = 1:2, fill = 5:6) # legend 추가 결과 attatch()는 데이터를 붙인다는 뜻인데, 데이터 내의 오브젝트에 이름으로 접근이 가능해진다. 그래서 바로 아랫줄에서 extra[1:10] 이런 식으로 서술이 가능하고, 이를 rbind()을 사용하여 행렬로 만든다. barplot()을 사용하려면 제일 앞에 들어가는 y를 이처럼 vector 혹은 matrix 형태로 바꾸어 주어야 한다. 함수 내부의 beside= 옵션은 TRUE일 때 데이터를 병렬적으로 보여주고, FALSE이면 하나의 막대에 전부 합쳐서 출력한다. 데이터셋 sleep으로 Barplot 그리기 (ggplot2)이번에는 동일한 barplot을 ggplot2 패키지를 사용해서 그려보자. 함수는 geom_bar()을 사용한다. 12345library(ggplot2)ggplot(sleep, aes(x=ID, y=extra, fill = group))+ # fill은 면의 컬러를 채울때 사용 geom_bar(stat = \"identity\", position = \"dodge\")+ # stat값을 identity로 지정하면 y 데이터를 높이로 사용 # position을 default로 놔두면 값이 쌓아지고, dodge를 할당하면 병렬적으로 출력됨 theme_bw() # data가 더 잘보이기 위한 테마 결과 먼저 ggplot()에서 인풋 데이터를 지정하고, aes 안에 x,y축 데이터를 지정하였는데 그다음에 fill = group이라는 옵션을 사용하였다. 대단히 자주 쓰이는 표현으로, group에 따라 면의 컬러를 다르게 칠하라는 뜻이다. geom_bar()은 본 패키지에서 barplot을 그리게 하는 함수로, 가장 자주 쓰이는 옵션이 바로 stat= 과 position=이다. stat은 statistic의 약자로, 바 그래프의 형태에 대해서 지정하는 옵션이다. stat=&#39;identity&#39;라고 쓰게 되면, y축 데이터를 높이로 하는 바 그래프를 그리라는 뜻이다. position은 막대의 위치를 의미하며, position=&#39;dodge&#39;는 여러 데이터를 독립적인 바 그래프로 나란히 표현할 때 사용한다. 이 옵션을 표기하지 않으면 데이터가 하나의 막대로 표시된다. position=dodge 를 표기하지 않았을 때 데이터셋 USPersonalExpenditure으로 Barplot 그리기먼저 USPersonalExpenditure가 어떤 형태인지 알아보자. Matrix의 형태로, 행에는 지출 항목, 그리고 열에는 년도가 기록되어 있다. 이들이 만나는 곳에는 실제 지출의 크기가 표기되어 있다. 이제 이 데이터를 최대한 잘 파악하기 위해, 년도별로 지출의 크기를 각 항목으로 나누어 바 그래프를 그려 보자. 12345data(USPersonalExpenditure) # Global Environment에 데이터 추가UPE &lt;- USPersonalExpenditure # 너무 길어서 간략화str(UPE) #데이터의 form확인 : numbarplot(UPE, beside = T, col = 2:6, xlab = \"Year\", ylab = \"Expenditure ($)\", main = \"United States Personal Expenditures\")legend('topleft', legend = row.names(UPE), fill = 2:6, cex = 0.7) # legend의 이름을 data의 row.name으로 결과 원하는 대로 깔끔하게 data visualization 에 성공했다! 앞선 sleep와 마찬가지로 데이터를 병렬적으로 표기하기 위해 beside=T 옵션을 넣었고, 각각의 막대 컬러를 2번 ~ 6번 색상으로 다르게 지정했다. 그리고 legend()를 사용하여 따로 범례를 추가하였는데, 범례 이름은 UPE의 행 이름으로 지정했고, 색상은 fill=을 사용하여 앞서 지정하였던 막대 컬러 2~6번과 동일하게 하였다. 또한 cex=가 등장하였는데, 이는 글자 크기를 조절하는 데에 사용하며 비율로 결정되므로 적절히 조절해서 숫자를 넣으면 된다. 자주 쓰이는 옵션이니 기억해 두자. 이어지는 포스트에서는 barplot 외에 자주 쓰이는 pie chart 와 histogram에 대해 다루어 볼 예정이다. 본 포스트는 KAIST 전산학부 대학원 과정에서 수강하고 있는 Big Data Analytics using R (CS564)을 실습하며 작성하였음을 밝힙니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"R","slug":"Programming/R","permalink":"http://jeongwookie.github.io/categories/Programming/R/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"R programming","slug":"R-programming","permalink":"http://jeongwookie.github.io/tags/R-programming/"}]},{"title":"R을 사용한 데이터 시각화, 1편","slug":"data-visualization-using-R-1","date":"2019-03-06T12:54:08.000Z","updated":"2019-03-17T15:25:47.579Z","comments":true,"path":"2019/03/06/data-visualization-using-R-1/","link":"","permalink":"http://jeongwookie.github.io/2019/03/06/data-visualization-using-R-1/","excerpt":"","text":"R은 데이터 시각화에 강력한 라이브러리들을 여럿 가지고 있어서 매우 유용하다. 이번 포스트에서 사용할 라이브러리는 아래와 같다. library : gglpot2 plotrix boot scatterplot3d lattice MASS 먼저, 내장 데이터셋인 faithful 을 기본 함수 plot()을 통해 그려보자. 123456789head(faithful)fa &lt;- faithful[order(faithful$waiting),] # waiting을 오름차순으로 정렬한 값을 fa에 저장head(fa)x &lt;- fa[,2]; y &lt;- fa[,1] # waiting을 x에, eruptions을 y에 저장plot(x,y,type=\"l\", col=4, xlab = \"Waiting Time\", ylab = \"Eruption Time\", main = \"Old Faithful Eruptions\")points(x,y, pch=20, col=3) # pch는 점의 생김새를 의미, 20은 작은 점 fa는 waiting 열을 order()을 통해 정렬한 faithful 데이터를 기록한 것이다. 즉, fa[,1] = fa$eruptions 이고, fa[,2] = fa$waiting 이다. plot()은 type을 지정할 수 있으며, 여기서는 line을 나타내었다. point()는 말 그대로 점을 찍는 함수이며, 여기서 점의 생김새를 결정하는 pch= 를 한번 보자. 여러가지 타입이 있다는 것만 알면 된다. 중요한 것은 pch= 가 점의 타입을 결정하는 요소이며 자주 쓰이는 것이 pch = 20(점), 21, 22, 23, 24, 25 라는 사실이다. 이번에는 동일한 데이터를 ggplot2 패키지를 통해서 그려 보자. 12345library(ggplot2)ggplot(fa, aes(x,y))+ geom_point(col=3) + geom_line(col=4) + # 점을 찍을 때 geom_point를 사용 xlab('Waiting time') + ylab('Eruption time')+ ggtitle('Old Faithful Eruption') 역시 ggplot2 답게 그래프 디자인이 조금 더 깔끔해 보인다. ggplot()함수는 어떤 데이터로 어느 축에 할당할 것인지 정한다. 이 함수만 출력하면 아무것도 plot되지 않음에 주의하자. 실제로 점을 찍고 선을 긋는 함수는 뒤에 있다. 자주 쓰이는 형태는 ggplot(data, aes(x = , y = , fill = ))으로, fill값에 대해서는 뒤에 다시 설명하겠다. geom_point()는 말그대로 점을 찍는 함수이다. 여기에도 여러가지 디자인 요소들이 있지만 자주 쓰이는 것은 col= 으로, 점의 색상을 결정한다. 이외에도 점의 모양을 결정하는 shape=, 점의 색상을 요소(factor)에 따라 변화하게 하는 aes(fill=), 점의 크기를 결정하는 size= 등이 쓰이는데 자세한 것은 여기를 참고하자. geom_line()은 선을 긋는 함수이다. 마찬가지로 col=4라고 적음으로써 4번 색상인 파랑을 출력하고 있다. 자세한 디자인 요소 변경은 여기를 참고하자. 이번에는 또 다른 내장 데이터인 diamonds 를 ggplot2로 그려 보자. 12345head(diamonds)library(ggplot2)ggplot(diamonds, aes(x=carat, y=price)) + geom_point(aes(col=color)) + # point의 컬러(col)를 color라는 변수값에 따라 변하도록 설정 facet_grid(color ~ .) # ~을 사용한 format ggplot()에서 x축 데이터를 carat열, 그리고 y축 데이터를 price열 로 설정하였다. 그리고 geom_point()로 점을 찍는데, 그 점들의 색상을 color열의 요소에 따라 달라지도록 지정하였다. 마지막으로, 새로운 함수가 하나 나타났는데 바로 facet_grid(). 주로 집단(group) 간의 효과적인 비교를 위해 면을 분할하고 싶을 때 사용한다. 또한, 많은 경우 x ~ y와 같은 형태로 작성하는데, 이는 표현 그대로 좌측은 x (input), 우측은 y (output)을 의미하는 간략한 함수 형태이다. 위의 facet_grid(color ~ .)은 color에 따라 나머지 모든 데이터를 그룹화 하여 면을 분할 해서 표현하라는 의미로 해석된다. 참고는 여기 만약 facet_grid(. ~ color)로 쓴다면, 쉽게 말해서 x와 y가 반전되어 출력된다. (세로) 왼쪽은 facet_grid(color ~ .) 이고, 오른쪽은 facet_grid(. ~ color) 의 결과물이다. 위의 geom_point() 세팅에 따라, 점의 색상이 diamonds$color의 값에 따라 달라짐을 알 수 있다. 이어지는 포스트에서는 기본 plot외의 bar, histogram 등의 형태를 다루어 볼 것이다. 본 포스트는 KAIST 전산학부 대학원 과정에서 수강하고 있는 Big Data Analytics using R (CS564)을 실습하며 작성하였음을 밝힙니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"R","slug":"Programming/R","permalink":"http://jeongwookie.github.io/categories/Programming/R/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"R programming","slug":"R-programming","permalink":"http://jeongwookie.github.io/tags/R-programming/"}]},{"title":"좋은 서비스 디자인하기","slug":"goal-directed-design","date":"2019-02-08T09:17:43.000Z","updated":"2019-03-18T14:33:12.404Z","comments":true,"path":"2019/02/08/goal-directed-design/","link":"","permalink":"http://jeongwookie.github.io/2019/02/08/goal-directed-design/","excerpt":"","text":"좋은 서비스, 소프트웨어를 만들기 위해서는 어떻게 해아 할까? 이는 비즈니스 초기부터 서비스 출시, 그리고 그 이후의 고객과의 인터렉션을 모두 포함하고 있는 궁극적인 질문일 것이다. 창업하는 이들 모두가 궁금한 이 질문에 대해 멘탈 모델을 기반으로 하는 방법론을 소개하고자 한다.(멘탈모델이 무엇인가는 멘탈 모델을 적용한 고객 인터뷰를 참고하자) 바로 목표 지향 디자인 방법론 (Goal Directed Design) 이다. 이것은 사용자의 목표를 이해하기 위한 하나의 프로세스 라고 이해하면 되는데, 여기서 사용자의 목표란 제품을 활용해서 자신이 성취하고자 하는 바가 무엇인지 또는 경쟁사 상품 대신 왜 이걸 선택하는지 와 같은 것이다. 많은 기존의 서비스들을 생각해보자. 혹시 사용하다가 스스로 멍청하다고 느껴본 적이 없는가? 서비스가 사용하기 너무 복잡하거나, 사용자가 실수할 법한 여지를 남겨두어 여지없이 거기에 걸렸다던가.. 나는 한글(.hwp)과 같은 문서 편집기를 사용하다가 키보드를 내려친 적이 몇번 있다. 우리는 사용자를 가르치려 드는 서비스를 만들려고 하는 것이 아니다. 이런 이상적인 서비스 개발에는 디자이너의 역할이 매우 중요하다. 또한 이들의 개입 순서가 어디인가에 따라 결과물이 크게 달라지는데, 윗 그림의 아래와 같은 방법을 따라가 보자. 목표 지향 디자인은 사용자의 목표와 니즈를 만족시킬 뿐 아니라, 사업 측면의 요구 사항과 기술 구현 가능성을 효과적으로 조화시킬 수 있는 접근 방식이다. 이 방식은 크게 리서치, 사용자 모델, 요구사항 도출, 디자인 설계, 수정, 관리 등 총 6가지 스텝으로 구성되어 있다. 이 중에서 비즈니스를 설계하는 최초부터 중요한 insight를 제공할 수 있는 첫번째 스텝을 본 포스트에서는 다루고자 한다. 디자인에 필수적인 요소를 깊이 이해하려면 반드시 정성적 리서치를 도입해야 한다. 무엇을, 어떻게, 왜 해야 하는지 명확한 답을 얻기 위한 것이 우리의 목표이다. 이때, 인터뷰 대상을 선정하거나 임원진 혹은 투자자에게 제품 구축을 납득시키기 위해서 기존의 정량적 리서치 (마케팅 리서치) 자료를 참고할 수 있다. 정성적 리서치는 훌륭한 디자인을 이끌어내는 지름길이다. 그렇다면 구체적으로 어떻게 정성적 리서치를 진행해야 할까? 아래의 구체적 프로세스를 설명하기 전, 실행하는 주체는 실제 서비스를 설계하는 사람 이라고 정한다. Step 1. 킥오프 미팅킥오프 미팅은 초기 창업자들 서로에게 질문하는 것으로도 유용하다. 앞으로의 제품, 사용자, 디자인 문제에 대해 어떻게 생각하는지에 대해 서로간 통찰이 생긴다. 핵심 질문은 아래와 같다. 제품은 무엇인가? (솔루션) 누가 사용하며, 사용할 것인가? (고객) 사용자가 무엇을 가장 필요로 하는가? (핵심 가치 및 기능) 어떤 고객과 사용자가 사업에 가장 중요한가? (핵심 고객 및 키 파트너) 팀은 프로젝트 진행 중 어떤 과제에 직면하는가? (운영) 어디를 가장 큰 경쟁사로 보는가? 그 이유는 무엇인가? (경쟁사 분석) 제품의 사업 및 기술 영역에 친숙해지려면 어떤 분야를 공부해야 하는가? 위 질문을 찬찬히 살펴보면, 창업자 스스로가 어떤 부분을 초기에 답변하려 아이템을 설계해야 하는지 알 수 있다. 또한, 초기 스타트업에 합류하는 팀원의 경우에도 같은 질문을 기존 경영진들에게 질문할 수 있을 것이다. 위의 질문들이 가장 첫번째 스텝임에 유의하라. 이는 창업자 개인의 생각일 수 있고, 사전에 진행한 리서치의 결과물일 수 있다. 답변을 충분히 듣고 (생각하고), 실제 서비스를 설계하는 것은 정성적 리서치의 모든 프로세스를 진행한 후에 해야 한다. Step 2. 문헌 조사킥오프 미팅을 진행함과 동시에 기존 문서의 내용을 잘 파악해야 한다. 창업자가 설계한 제품 (서비스)과 관련된 영역에 관한 문헌을 조사한다. 여행 관련 플렛폼에 대한 아이디어라면 여행 트렌드, 관련 기사, 플렛폼에 관한 이해 등이 여기에 해당한다. 이는 인터뷰를 진행하기 전, 질문할 내용을 준비할 때에 큰 도움이 된다. 또한 사용자 조사에서 얻은 자료를 분석할 때에도 중요한 기반이 된다. Step 3. 기존 제품 및 경쟁사 분석기존의 제품과 주요 경쟁사 제품 분석은 현재 사용자에게 제공되고 있는 기능을 분명히 이해할 수 있도록 돕는다. 다만, 너무 구체적인 기능에 대한 조사는 지양하는 것이 좋아 보인다. 자칫하다가는 기존의 프레임에 생각이 갇힐 위혐이 있다. 가볍게 경쟁사의 고객 전달 가치가 무엇인지, 그리고 마켓 포지셔닝을 어떻게 하고 있는지 정도가 적절하다. (투자 및 매출 현황도 같이 살피면 유용할 것이다) Step 4. 임원진 인터뷰임원진 인터뷰는 제품을 디자인하기 전 사업 목표를 분명히 이해하는 데에 큰 도움이 된다. 초기 스타트업은 창업자의 초기 비전을 들어보는 것이다. 임원진 인터뷰에서 얻을 수 있는 중요한 정보는 다음과 같다. 초기 비전과 기대: 팀원들의 완성 제품에 대한 기대치가 제각각인 경우가 많다. 비용과 일정: 얼마나 많은 자원을 투자할 수 있는지 명확히 하는 것은 매우 중요하다. 기술적 제약과 가능성: 현재 구현할 수 있는 범위가 어느 정도인지 파악하여야 한다. 사업 전략: 성취하려는 사업 목표가 무엇인지 알면 차후 중요한 의사결정을 내릴때 큰 도움이 된다. 임원진이 생각하는 사용자: 팀원마다 주요 예상 사용자가 다를 수 있다. Step 5. 영역 전문가 인터뷰디자인 프로젝트 초기에 영역 전문가에게 자문을 구하는 것은 때론 매우 중요할 수 있다. 영역 전문가란 디자인하려는 제품의 분야를 매우 잘 아는 사람을 의미한다. 예를 들어 의료 분야의 스타트업은 보통 설계하려는 아이템이 복잡하고, 기술집약적이며, 법적 고려를 해야하는 경우가 많은데, 디자인을 시작하기 전 자문을 구하는 것은 필수적이다. 다만, 영역 전문가들을 인터뷰할 때에는 아래와 같은 주의가 필요하다. 영역 전문가는 고급 사용자임에 유의하여야 한다. 이들은 기존 제품에 너무 익숙하여 새로운 디자인을 제시하기는 어렵다. 또한 같은 기능이라도 전문가만 사용할 수 있는 기능을 선호하는 경향이 있다. 영역 전문가의 의견은 중요하지만, 그들이 디자이너는 아니다. 실제로 그들이 내놓은 아이디어가 도움이 될수도 있고, 아닐 수도 있다. “이 가능이 사용자에게 어떤 도움이 될까?” 를 항상 염두하자. 복잡하고 전문적인 분야일수록 영역 전문가가 필수적이다. 이들의 지식을 활용하면 복잡한 사용자 리서치를 보다 쉽게 설계할 수 있다. 지속적으로 영역 전문가를 만나서 자문을 구해야 한다. 이들이 꼭 필요한 제품을 만든다면, 디자인을 진행하는 동안 여러 번 만나서 자문을 구하여야 한다. Step 6. 구매자 인터뷰구매자는 사용자와 다른 개념이다. 구매자란 제품의 구매 의사결정을 내라는 사람을 말한다. 일반적인 소비 제품의 경우에는 구매자와 사용자가 동일하지만, 대부분의 경우 다르다. 어린이용 제품의 사용자는 어린이지만 구매자는 부모이며, 기술 제품의 경우에도 사용자는 직원이지만 구매자는 이사급 임원진 혹은 IT관리자이다. 성공적인 제품을 디자인하려면 반드시 구매자의 목표를 이해하고, 이들을 만족시켜야 매출로 연결된다. 제품을 구입하는 목표 현재 사용중인 제품에서 겪는 어려움 유사한 제품 구입 시 의사결정 과정 제품의 설치, 유지, 관리에서 구매자의 역할 사업 영역의 특징과 이슈 때때로 이들을 인터뷰하는 도중 더 훌륭한 아이디어를 발견할 수 있다. 구매자가 왜 그런 의견을 냈는지 분석하는 과정이 그래서 매우 중요하다. Step 7. 사용자 인터뷰디자인의 중심은 항상 사용자이다. 이들이 바로 실제로 제품을 가장 활발하게 사용하기 때문이다. 이들을 이해하려면 실제로 사용자가 제품을 이용하는 공간에서 조사를 진행햐난 것이 바람직하다. 그렇다면 구체적으로 어떻게 사용자를 인터뷰 하는 것이 좋을까? 가장 효과적인 방법은 사용자 관찰과 일대일 인터뷰를 병행하는 것이다. 이러한 방법론을 에스노그라피 인터뷰 (Ethnographic Interview) 라고도 한다. 에스노그래피는 원래 인류학에서 주로 사용하는 용어인데, 인류의 문화에 대한 체계적이고 집중적인 연구를 의미한다. 인류학자들은 연구를 진행할 때 해당 문화를 직접 체험하면서 수녕간 자료를 기록하고 분석한다. 이러한 기본 컨셉을 소규모 리서치에 적용한 것이다. 사용자 조사에서는 사용자와 제품이 어떻게 인터렉션 하는지 사용자의 행동 패턴과 태도를 이해하는 게 목표이다. 구체적으로 에스노그라피 인터뷰를 진행하는 데에 염두해야 하는 내용은 아래와 같다. 직접 사용자를 찾아가 인터뷰하라. 정해진 질문지를 피하라. 전문가가 아니라 초심자의 역할을 가정하라. 끝이 있는 질문과 없는 질문을 적절히 하여 논의를 유도하라. 사용자의 목표를 먼저, 과업은 나중에 파악하라. 사용자는 디자이너가 아니다. 기술에 대한 토론은 하지 않는다. 사용자의 이야기를 들어라. 사용자의 업무와 작업물을 관찰하라. 유도 질문을 피하라. 인터뷰를 진행하면서, 사용자가 제품에 대한 디자인 의견을 제시하는 경우가 있다. 이때, 의견 자체에 초점을 맞추기 보다는 왜 그렇게 생각하는지 뒤에 깔린 목표를 파악하여야 한다. 아래와 같이 질문해 보자. “그렇게 하면 어떤 문제가 해결될까요? “왜 그렇게 바꾸고 싶은가요? 디자인 프로세스의 초기 단계에 에스노그라피 인터뷰를 진행하면 매우 값진 결과를 얻을 수 있다. 사용자를 깊이 이해하고, 사용자의 니즈와 목표를 파악하여 좋은 서비스를 만드는 데에 도전해 보자. 위 포스트는 About Face, 인터렉션 디자인의 본질을 읽고 작성하였습니다.","categories":[{"name":"Marketing","slug":"Marketing","permalink":"http://jeongwookie.github.io/categories/Marketing/"},{"name":"Design","slug":"Marketing/Design","permalink":"http://jeongwookie.github.io/categories/Marketing/Design/"}],"tags":[{"name":"디자인 리서치","slug":"디자인-리서치","permalink":"http://jeongwookie.github.io/tags/디자인-리서치/"},{"name":"창업","slug":"창업","permalink":"http://jeongwookie.github.io/tags/창업/"}]},{"title":"문득 떠오른 취미","slug":"find-a-new-hobby","date":"2019-02-02T17:38:28.000Z","updated":"2019-02-07T17:45:17.000Z","comments":true,"path":"2019/02/03/find-a-new-hobby/","link":"","permalink":"http://jeongwookie.github.io/2019/02/03/find-a-new-hobby/","excerpt":"","text":"&lt;문득 든 배우고 싶은 취미에 대한 일기&gt; 나는 음악을 많이 듣는 편은 아니다. 기차를 타고, 버스를 타고 갈 때에도 잠을 청하기 위해 가끔 음악을 듣곤 하지만.. 아무것도 귀에 꼽지 않고 갈때가 훨씬 많다. 하지만 가끔 좋은 뉴에이지 음악을 들을 때, 음색이 매력적인 기타 소리를 들을 때 나도 저렇게 연주하고 싶다는 생각은 종종 든다. 어머니께서 내가 초등학생이 되기 전까지 성악을 하셨다. 연주회에 가서 어머니를 기다렸던 기억이 조금씩 난다. 종종 방학때는 같이 유명한 피아니스트의 연주회에 갔었다. 물론 어릴때는 그때마다 저녁에 양식을 먹을 수 있어서 따라갔던 것이 크지만.. 좋은 음악을 들을 때 마다 그때의 기억이 나는 것을 보면 좋았던 모양이다. 초등학교때 많은 또래들이 그랬듯이 학원을 다니면서 피아노와 플룻을 배웠다. 정말 어릴때는 집에서 친구들과 함께 어머니께 노래를 배우기도 했었다. 근데.. 어른이 된 지금은 하나도!! 내 손가락에 남아있지 않다..ㅠㅠ 대학교 1학년때는 일렉 기타를 배워보려고 수업을 신청했었는데, 조금 만져보다가 도망갔다 ㅋㅋㅋ 아버지께서 강력히 추천하셨었지만.. 나한테는 맞지 않았던 모양이다. 손이 남들보다 작고 악력이 없어서 내 맘대로 음이 울리질 않으니 흥미가 떨어졌다.(락과 같은 영역의 노래를 하나도 안듣기도 했다) 지금은 피아노를 기회가 되면 한번 더 배워보고 싶다. 내가 치고싶은 곡들만 연습해서 멋지게 연주하고 싶다. 보컬 수업도 한번 듣고 싶다. 목소리는 솔직히 자신있는데.. 노래방을 거의 안가다 시피 해서 어떻게 부르는지 모른다 ㅋㅋㅋ 이번 해에 할 수 있을까? 도전해 보자..!!","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"취미","slug":"취미","permalink":"http://jeongwookie.github.io/tags/취미/"},{"name":"고민","slug":"고민","permalink":"http://jeongwookie.github.io/tags/고민/"}]},{"title":"IBM Watson 다루기","slug":"AI-development-training-course-in-kaist","date":"2019-01-22T09:22:49.000Z","updated":"2019-01-24T09:39:57.000Z","comments":true,"path":"2019/01/22/AI-development-training-course-in-kaist/","link":"","permalink":"http://jeongwookie.github.io/2019/01/22/AI-development-training-course-in-kaist/","excerpt":"","text":"12월 말 정도부터 거의 매일 학교에서 저녁에 열렸던 AI 관련 특별 강좌를 이수했다. 원래는 TensorFlow 기본을 수강하려 했는데 수강 인원이 꽉 차버려서..ㅠㅠ 예전에 왓슨을 이용해서 간단한 챗봇은 구성해본 경험이 있어서, 왓슨의 다양한 기능들을 사용해 보고 프로젝트에 써먹을 수 있는 것이 있을까 파악하는 것도 재미있어 보였다. 이 수업에서는 기본적으로 IBM Watson의 다양한 기능들을 사용해보고, 이를 비즈니스에 실제로 적용할 때에 구성 방식에 대해서 배웠다. 제일 처음은 Watson Assistant를 사용한 피자 배달 챗봇 만들기부터 ㅋㅋㅋ 예전에 구성했던 챗봇은 선택지를 미리 정해놓고 케이스만 나누어서 응답하는 가장 기초적인 응답 챗봇이었기 때문에, 이번에는 선택지 없이 계속 케이스를 러닝 시키면서 accuracy가 올라가도록 구성해 보았다. 이후에는 Watson Discovery 및 Watson Knowledge Studio를 사용해서 기업 내부의 아카이브 된 지식 체계들을 쉽게 검색할 수 있도록 데모를 만들어 보았고.. 여러가지 검색어를 트라이 해보면서 놀았다. Watson의 또 하나의 서비스인 Visual Recognition도 대단히 흥미로운 툴이었다. 분류자를 직접 만들어서 내가 가지고 있는 로컬 서버의 이미지 파일들을 정돈하는 데에 수 초가 걸리지 않았다. 결과도 꽤나 정확했던.. 물론 내가 직접 찍은 사진들은 너무 local스러워서 러닝이 더 필요해 보이긴 했지만. 새로운 툴을 만져 보는 것은 언제나 즐겁다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Tools","slug":"Programming/Tools","permalink":"http://jeongwookie.github.io/categories/Programming/Tools/"}],"tags":[{"name":"IBM Watson","slug":"IBM-Watson","permalink":"http://jeongwookie.github.io/tags/IBM-Watson/"},{"name":"AI","slug":"AI","permalink":"http://jeongwookie.github.io/tags/AI/"},{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"}]},{"title":"컴퓨터방 셀프 인테리어, 마지막","slug":"house-remodeling-4","date":"2019-01-17T12:51:53.000Z","updated":"2019-01-19T14:18:36.000Z","comments":true,"path":"2019/01/17/house-remodeling-4/","link":"","permalink":"http://jeongwookie.github.io/2019/01/17/house-remodeling-4/","excerpt":"","text":"셀프 인테리어 마지막 포스트! 이전 포스트는 아래 링크를 누르면 볼 수 있다. 처음 시도하는 셀프 인테리어 도전기 1탄, 페인트 칠하기 처음 시도하는 셀프 인테리어 도전기 2탄, 바닥 깔기 처음 시도하는 셀프 인테리어 도전기 3탄, 조명 설치하기 이번에는 마지막에 리모델링에 사용된 비용과 출처를 정리하였으니 관심있는 초보자 분들의 많은 참고가 되었으면 한다. 우리가 리모델링한 작업을 아래에 간단히 정리해 보았다. 방문 &amp; 굽도리 화이트 톤으로 채색 블랙 문고리, 화이트 경첩으로 방문 깔맞춤 남는 페인트로 화장실문 페인팅 방 내부 데코타일 시공 방 내부 레일 조명 설치 창문에 암막 커튼 설치 방 벽면에 Lack 설치 (예정) Lack은 컴퓨터 책상 위 벽면에 설치하려고 이케아에서 주문했는데, 막상 배치를 다 하고 나니 힘들어서 나중에 하기로 결정..ㅋㅋ 여기는 적지 않았지만, 작은 방은 벽면까지 회색 계열로 풀바른 벽지를 붙였다. 이것도 스토리가 있는데.. 결론은 보기보다 쉽지 않다는 거. 작은 방 해보고 힘들어서 큰 방은 안하기로 결정했다. 이제 결과를 공개할 시간! 가구는 솔직히 비싸서 신경을 많이 못썼다. 중간중간에 여유 되는대로 채워넣을 계획이다. 이렇게 보니 침구류의 퀄리티가 좀..ㅋㅋㅋ 색상이 안맞아서 새로 깔아야겠다. 여기까지 2주 조금 넘게 걸린 것 같다. 학교에서 교육듣고 와서 밤에 틈틈히 작업한거라 오래 걸리긴 했지만 이사일까지 결국 마무리지었다. 사진으로 보니까 방이 아니라 무슨 스튜디오 같은데 ㅋㅋㅋㅋ 방송이라도 해야할 것 같군. 컴퓨터방 인테리어는 뭐니뭐니해도 모니터가 이목을 확 끄는 것 같다. 이걸 위해서 두닷 콰트로에서 제일 큰 책상을 주문했다. 모니터는 알파스캔 커브드 모델로 가운데 메인 모니터는 144hz, 측면 두개는 75hz까지 가능한 제품이다. 마지막으로, 리모델링 비용과 가구 구매 비용을 아래에 정리했다. 혹시 구체적인 구매처가 궁금하시면 댓글 달아 주세요! 답 달아 드리겠습니다 :)","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"취미","slug":"취미","permalink":"http://jeongwookie.github.io/tags/취미/"},{"name":"셀프 인테리어","slug":"셀프-인테리어","permalink":"http://jeongwookie.github.io/tags/셀프-인테리어/"}]},{"title":"컴퓨터방 셀프 인테리어, 세번째","slug":"house-remodeling-3","date":"2019-01-11T15:07:03.000Z","updated":"2019-01-16T17:24:20.206Z","comments":true,"path":"2019/01/12/house-remodeling-3/","link":"","permalink":"http://jeongwookie.github.io/2019/01/12/house-remodeling-3/","excerpt":"","text":"셀프 인테리어 세 번째 포스트. (1탄 포스트 링크, 2탄 포스트 링크) 지금까지 진행한 사항을 아래에 간단히 정리해 보면, 방 두개 문 &amp; 굽도리 페인트칠 완료 방문 문고리 부착 완료 화장실 문 1/3 완료 방 두개 데코타일 시공 완료 이제 남은 작업은 조명 설치와 가구 조립. 1월 8일은 그전날 바닥 작업의 여파로 쉬었습니다..ㅠㅠ (진짜 완전 힘듬) 1월 9일 ~ 1월 10일 : 레일 조명 설치하기역시 방 인테리어의 아름다움은 조명빨 아니겠는가? 패기있게 요즘 유행하는 레일조명을 LED램프로 구매했다. (대부분의 카페에서 사용하는 예쁜 조명) LED 전구는 개당 12W의 밝기를 가지고 있으며 6개니 총 72W. 방 전체를 커버할 수 있을까 의심이 되었지만.. 하나 더 사기에는 자금이 ㅠㅠ 그래서 일단 달아보고 판단하기로 했다. 레일 조명 설치는 실전! 레일조명 설치해보기, 오늘의집 포스트를 참고했다. 작업 순서는 대략적으로 아래와 같이 진행했다. 기존 등을 조심스럽게 제거한다. 전원선의 상태를 확인하고 이를 기준으로 레일 등의 위치를 정한다. 천장에 레일을 설치한다. 레일 시작점 부분까지 전원선을 확장하여 연결한다. 레일에 조명을 달고 마무리한다. 우리 집의 기존 조명은 그냥 일반적인 형광등이었다. 이걸 분해하면 전원선이 나오는데, 너무 전원선과 멀리 설치를 하면 연장선이 길어져서 보기 싫다고 한다. 그래서 적당한 거리를 두고 ㄱ자 형태로 레일 조명을 설치하기로 결정! 근데.. 문제가 생겼다. 포스트를 보면 전원선을 길게 뽑아낼 수 있던데, 저 사진에 보이는 길이가 한계였다!! 전원선을 많이 연장해야 해서 다른 전선이 필요했다. 포스트에서는 기존 조명에서 전선을 떼어다가 전기테이프로 이어붙이라고 하던데.. 기존 전선의 길이들이 전부 답이 없게 짧았다 ㅠㅠ 이미 밤 11시라 주변 철물점들은 전부 문을 닫아서, 일단 놔둬놓고 레일부터 고정을 해보기로 했다. 그리고 결론적으로 오늘 작업은 더이상 못하게 되었다.. 레일 조명을 설치할때, 주의할 점은 바로 천장의 상태이다. 레일이 단단히 고정되어야 하는데, 천장이 석고라면 떨어질 위험이 있어서 나무 천장에다가 박아야 한다. 근데 천장을 톡톡 치고 나무임을 확인한 후에 레일을 박으려 했는데 드릴에 문제가 있는건지 나사가 박히지 않는것이다..!! 그러다가 홧김에 다른 곳에다 드릴을 댔는데 여기는 석고였는지 구멍이 뻥 뚫렸다 으악! 얼른 실리콘으로 막아버리고 전선도 없겠다 포기 선언. 다음날 그냥 전문가를 부르기로 했다.. 다음날 출장 설치 오신 한빛전기조명설비 전문가님. 네이버 블로그의 후기들을 여러개 참고해서 괜찮은 분을 선택해서 전화 신청했다. 너무 깔끔하게 작업해주신 전문가님. 출장비는 5만원 들었다. 레일 조명은 조금 복잡한 작업이라 일반 조명보다 비싸게 받으신다고 하더라. 옆에서 보았는데, 우리가 절대 따라할 수 없는 퀄리티의 작업이었다 ㅋㅋㅋㅋ 직접 조명 설치는 실패했지만, 아무튼 조명 설치 끝! 레일 조명을 혼자 작업하고 싶다면 좋은 드릴과 예비 전선을 구비하고 시도하시길. 1월 11일 : 책상과 선반 조립전체적인 방 리폼은 끝났다. 벽지는 너무 넓고 힘들것 같아서 패스 (작은방만 작업했다) 두닷 (Dodot)에서 주문한 1800 X 800 사이즈의 컴퓨터 책상이 도착했다. 예전에는 1600 X 700 책상을 사용했는데, 확실히 크다. 큼지막해서 마음에 들고, 딱 봐도 엄청 튼튼해 보인다. 모니터를 여러개 놓을꺼라, 아무래도 전문가의 손길이 필요할 것 같아서 9천원을 추가해서 조립 포함하는 플랜으로 구매했었다. 그리고 동시에 도착한 일명 짭케아 철제 서랍장. 일일히 서랍 하나하나를 만들어주어야 한다. 조립하는데 꽤나 애먹은 제품. 완성하고 보니 모양은 봐줄만한데, 마감이 그리 좋지는 않다. 여기에다가 침대와 책장을 놓고, 옷걸이용 행거를 설치할 예정이다. 생각보다 넓어서 아늑한 느낌은 아니지만, 약간 스튜디오 느낌이 나는 방이 될 것 같다 ㅋㅋㅋ 다음 포스트는 최종 마무리로!","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"취미","slug":"취미","permalink":"http://jeongwookie.github.io/tags/취미/"},{"name":"셀프 인테리어","slug":"셀프-인테리어","permalink":"http://jeongwookie.github.io/tags/셀프-인테리어/"}]},{"title":"컴퓨터방 셀프 인테리어, 두번째","slug":"house-remodeling-2","date":"2019-01-09T11:11:00.000Z","updated":"2019-01-16T17:20:08.328Z","comments":true,"path":"2019/01/09/house-remodeling-2/","link":"","permalink":"http://jeongwookie.github.io/2019/01/09/house-remodeling-2/","excerpt":"","text":"셀프 인테리어 두 번째 포스트. (1탄 포스트는 여기) 현재 진행 상황을 간단히 정리해 보았다. 방문 두개 프라이머 1회, 페인트 2회 완료 방문 문고리 부착 완료 방 두개 굽도리 프라이머 1회, 페인트 2회 완료 화장실 문 프라이머 1회 완료 1월 6일 ~ 1월 7일 : 바닥 데코타일 시공하기그 다음 우리의 목표는 바닥이다. 현재 바닥은 시멘트 바닥 위에 장판이 깔려 있는 형태. 장판을 뜯는 것은 집주인이 혀용하지 않았고, 만약 새로 바닥을 깔고 싶으면 깔아도 되긴 하는데 다시 뗄 수 있도록 제한적으로 허용했다. 그래서 우리가 생각한 것은 본드를 사용하지 않는 점착식 데코타일. 데코타일이란 것이 원래 일반 가정집에 시공하는 것은 아니라고 한다. 그런데, 셀프 인테리어 붐이 일면서 적당히 가정집 바닥에도 붙일 수 있게 변형된 형태가 등장했고, 이것이 바로 점착식 데코타일. 두께에 따라서 종류가 있는데, 그냥 기본인 2t짜리로 주문했다. 색상은 조금 차분한 인상의 방을 만들기 위해 어두운 나무톤의 로즈우드 색을 선택. 아참, 주문 할때 페인트와 똑같이 몇 개의 데코타일을 주문할 것인지 의문이 들 것이다. 다행히 하나리빙데코 구매 사이트에 접속하면 대략 몇 제곱 미터에 얼마의 데코타일이 드는지 나와있다. 내 방 (W480 x D400) 기준으로 약 11개 조금 넘는 박스가 필요했다. (1박스 당 11장) 이제 데코타일을 붙이기 시작! 붙이는 방법은 이승훈 님의 집꾸미기 포스트 와 나르의 인테리어 TV를 참고했다. 전체적인 작업 순서는 아래와 같이 진행했다. 방의 4면 중 기준이 되는 면 &amp; 모서리를 정한다. 데코타일을 가로 &amp; 세로로 방이 꽉 차도록 늘어놓아 본다. 대략적인 시공 시 필요 갯수를 확인하고, 1/4 크기의 타일과 1/2 크기의 타일을 잘라서 만든다. (1/4 크기로 무늬 만들기) 마구마구 붙인다! 남은 부분 + 틈새를 작은 타일을 만들어 보수한다. 1차적으로 다 붙이면서 느낀 문제점들이 있다. 첫째, 둘이서 작업할 때 한명은 위에서부터, 한명은 사이드 벽면에서부터 붙여 나갔는데 나중에 만나는 지점을 보니 붙일 수 있는 면적이 모자라거나 남는 부분이 생겼다. 보수하기 위해서 다시 다 떼고 붙이고를 반복했다..ㅠㅠ 둘째, 기준으로 삼은 벽면에서부터 출발해서 반대쪽 벽면까지 붙여나가는데 마지막 장판의 크기가 뒤죽박죽이었다. 이걸 일일히 사이즈를 재고 칼로 잘라서 붙였는데 마감이 안좋기도 하고 무엇보다도 매우매우 힘들다!!! 솔직히 말해서 그냥 쭉 붙이는 건 즐거웠는데, 끝 부분 재단하고 붙이는데 그냥 포기하고 싶었다 ㅠㅠㅠㅠ 1차로 한번 쭉 붙이는데 약 1시간 30분, 끝 부분 재단하고 붙이는 데 약 3시간 이상 걸렸다. 중간에 힘들고 배고프고 그래서 페인트와 쓰레기 더미들 사이에서 라면을 끓여먹었다..ㅋㅋㅋ 페인트 칠은 즐겁지만 바닥에 데코타일 까는 건 다시 한번 고민해 보길 강력히 추천한다.. 허리 휘어질 것 같아서 새벽 5시 반에 작업 끝나고 방 들어와서 파스 붙이고 자고 그랬으니. 아무튼 바닥까지 끝!! 다음 포스팅은 조명과 남은 인테리어로 돌아오겠습니다.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"취미","slug":"취미","permalink":"http://jeongwookie.github.io/tags/취미/"},{"name":"셀프 인테리어","slug":"셀프-인테리어","permalink":"http://jeongwookie.github.io/tags/셀프-인테리어/"}]},{"title":"컴퓨터방 셀프 인테리어, 첫번째","slug":"house-remodeling-1","date":"2019-01-05T12:34:22.000Z","updated":"2019-01-16T15:33:18.660Z","comments":true,"path":"2019/01/05/house-remodeling-1/","link":"","permalink":"http://jeongwookie.github.io/2019/01/05/house-remodeling-1/","excerpt":"","text":"인터넷 커뮤니티 클리앙에 올라온 혼자서 한 컴퓨터방 리모델링을 보고 느낌이 와서 계획한 투룸 리모델링. 현재 살고 있는 집은 1.5룸인데 친구랑 둘이 살기 너무 좁아서 1년만 채우고 투룸으로 이사가기로 했었다. 이왕 이사가는 김에 얼마나 살지는 모르겠지만 인테리어 한번 해볼까? 하고 시작 ㅋㅋㅋ 심지어 집 구할때도 제일 큰 조건 중 하나가 “이집 뜯어고쳐도 돼요?” 였다.. 우리는 컴퓨터쟁이니까 방은 컴퓨터방 리모델링 사진들을 많이 참고했고, 원래는 가구 배치나 여러가지 인테리어 소품들도 막 살펴봤지만 예산이..ㅠㅠ 1주일에 걸쳐서 총 15번 이상 각각 다른 투룸들을 방문하면서 좋은 물건(?)을 물색했고, 12월 30일 큰방 + 작은방 + 분리 주방 + 베란다 2개 형태의 방으로 확정지었다. 방 스펙 : W480 x D400 x h207 (m) 우리 스펙 : 인테리어 경험 전무, 27세 남자 두명 1차 결정 사항 : 문 페인트칠, 바닥 시공, 조명 교체, 커튼 설치 12월 31일 : 페인트 구매 다음날 곧바로 대전 둔산동에 위치한 벤자민 무어 (Benjamin Moore) 페인트 샾에 다녀왔다. 원래 방문 전에는 이분을 참고해서 총 3가지 색상을 구매하려 했는데, 생각보다 가격이 비싸서 그냥 하나로만 칠하기로 결정. 우리가 정한 색상은 클라우드 화이트 (Cloud White) 이다. 이걸로 문을 칠하고, 굽도리도 칠하기로 했다. 벽지도 원래는 떼어내고 투톤으로 칠하려 했는데, 돈이 무지막지하게 많이 들어서 포기..ㅠㅠ 페인트 1 갤런, 프라이머 2 리터, 롤러 외 기타 페인트 용도의 물품들 구매에 약 18만원 정도 소비되었다. (최종 포스트에서 총 사용한 비용을 표로 정리할 계획이니 참고) 참고로, 프라이머 (Primer)는 페인트를 칠하기 전, 이미 도색된 곳에 발라서 원래의 색을 묻는 역할을 한다. 다른 말로 젯소 (Gesso)라고도 한다. 색칠 전에 흰색 계열로 바탕을 칠해준다고 생각하면 될듯? 프라이머에 대해 자세히 알고 싶다면 여기를 참고하자. 또한, 페인트를 구매하기 전 제일 고민되는게 “페인트를 얼마나 사야하지??” 였다. 처음에는 인터넷으로 페인트를 구매하려 했기 때문에 수량을 미리 알아야 했고, 오늘의 집: 페인트 양 계산하기를 주로 읽었다. 그래도 감이 안잡혀서 오프라인 매장을 방문하기로 결정했는데, 정답이었다. 대충 수치만 알아가도 벤자민 무어의 엄청난 고객 응대 서비스에 감탄하면서 고개를 끄덕이며 페인트를 들고 나올 수 있다고 확신한다. 받아본 적은 없지만, 비싼 양복점에서 맞춤 정장을 사는 기분이었다. 벤자민 무어 페인트 : 극상의 오프라인 고객 응대, 냄새가 전혀 나지 않는 친환경 페인트, 수많은 후기가 증명하는 페인트 색감의 우월함 1월 1일 ~ 1월 2일 : 방문 프라이머 칠하기우리가 정한 집의 가장 큰 문제가 방문이다. 문고리는 쭈글쭈글하고, 경첩은 녹이 슬어 있었으며, 무엇보다도 방문의 색깔이 너무 촌스러웠다. 작업 순서는 아래와 같이 진행했다. 방문 손잡이 제거 물티슈로 더러운 얼룩 닦아내기 마른 걸레로 먼지 제거 마스킹 테이프로 방문 틀과 아래쪽 마킹 프라이머 도색 하루 칠해보고 안 사실이 있다. 잘 칠하려면 처음에는 작은 붓으로 사이사이 테두리를 그려야 한다는 것 넓은 면은 무조건 롤러를 사용해야 한다는 것 살살 해도 바닥에 많이 튄다는거.. 물론 옷에도 ㅠㅠ 셋 다 다 칠하고 나서 안 사실이다 ㅋㅋㅋㅋ 처음 문은 망함 ㅋㅋㅋㅋㅋ 바닥도 엉망 ㅋㅋㅋㅋㅋㅋ 그래도 처음으로 붓칠 하면서 느낀 점은.. 생각보다 재밌다?! 새로운 취미가 생긴 기분이다. 물론 바닥에 튄 프라이머 긁어낸다고 고생하긴 했지만 ㅋㅋ 1월 3일 ~ 1월 4일 : 방문 페인트 찰하기위에서 언급한 대로, 우리가 정한 방 문 색상은 Cloud White이다. 프라이머가 잘 마른 것을 확인하고 1회차 페인트 칠, 그리고 그 다음날 다시 와서 2회차 페인트 칠을 진행했다. 1월 5일 : 굽도리 페인트 칠하기 &amp; 방문 손잡이 달기그 다음날은 방 전체 굽도리 페인트 칠을 진행했다. 여기서 중요한건, 페인트칠이 아니라 각 부분에 마스킹 테이프가 꼼꼼하게 붙여져 있어야 한다는 것이다. 천장과 바닥에 붙인 마스킹 테이프를 다시 보수해 주고, 작업 시작! 문고리는 셀프 인테리어 물품 판매 사이트중에서 유명한 문고리닷컴에서 제일 인기 많은 블랙 색상의 문고리를 부착했다. 흰색 경첩도 달아야 완벽한데, 아직 전동 드릴이 없어서 그대로 놔두었다. 한 4일 정도 걸려서 양쪽 방문 &amp; 굽도리 페인팅을 끝냈다. 수업도 가고 일도 하는 와중에 밤에 와서 조금씩 작업을 한 탓에 좀 오래 걸리긴 했지만 만족! 다음 포스트는 바닥 깔기로 찾아오겠습니다..ㅎㅎ","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"취미","slug":"취미","permalink":"http://jeongwookie.github.io/tags/취미/"},{"name":"셀프 인테리어","slug":"셀프-인테리어","permalink":"http://jeongwookie.github.io/tags/셀프-인테리어/"}]},{"title":"2018년의 끝에서","slug":"happy-new-year","date":"2018-12-31T13:52:26.000Z","updated":"2019-01-31T13:55:36.054Z","comments":true,"path":"2018/12/31/happy-new-year/","link":"","permalink":"http://jeongwookie.github.io/2018/12/31/happy-new-year/","excerpt":"","text":"2018년 한해가 벌써 끝났다.. 아쉬운 일이 많았던 올해. 나는 무엇을 했을까? 1월에는 12월까지의 창업 활동을 마무리하고, 새로운 기회가 있는지 찾아다녔다. 블록체인 컨퍼런스에도 몇번 참여했고, 투자자분이 주선한 비즈니스 미팅도 수회 진행했었다. 조금 마음이 조급했던 시기였지.. 2월에는 우여곡절 끝에 GIST를 무사히 졸업했다. 지도교수님과 공동 지도교수님의 도움을 크게 받았다.. 그분들께는 정말 감사한 마음 뿐이다. 설에는 가족들과 괌을 다녀왔다. 리프레쉬의 기간이었던 것 같다. 3월에는 KAIST 기술경영학부 대학원에 입학을 했고, 대전에 슬슬 적응하면서 학교 수업을 들었다. 한창 사업한다고 서울에서 뛰어다니다가 오랜만에 강의실에 앉아서 수업을 들으니까 기분이 이상해 ㅋㅋㅋ 4월에는 여러 고민 끝에 모 기업과 우리 팀의 협업을 결정했다. 3층 스타트업 오피스 시절. 5월에는 후쿠오카, 가고시마 등 총 두번의 일본 여행을 다녀왔다. 한창 바쁠 시기였는데 둘다 뜬금포로 막 3~4일 전에 결정해서 그 주 주말에 날치기로 다녀온.. 6월에는 한창 학교 오피스에서 일했다. 기말고사 시즌에다가 맡은 일도 많아서 여러가지로 힘들었다. 학기 끝나자마자 팀 워크샵을 다녀왔다. 7월에는 카이스트 전산학부 출신의 새로운 친구와 같이 일하게 되었다. 중간에는 예전에 행사할 때 사놨던 항공편이 있어서 ㅋㅋㅋ 다카마쓰를 다녀왔다. 8월에는 본격적으로 개발에 착수하게 되었는데.. 중간에 삐걱거림이 있었지. 원격으로 일하는 게 이렇게 힘들다니.. 여러가지로 생각이 많이 드는 시기였다. 역시 사람이 제일 문제구나.. 이런거? 9월에는 새학기가 시작되었고, 학교에서 파이썬 교육을 들었다. 답답해서 나도 개발을 시작해야겠다는 생각이 강하게 들었다. 앞으로 어떤 방향으로 삶을 설계해야 할지 많은 고민이 있었던 시기.. 너무 걱정을 많이해서 그런가 또 몸이 안좋아졌었다 ㅠㅠ 하나 좋은 기억이 있다면 새로운 비젼을 가진 사람들을 만났다는거? 10월에는 원격으로 협업하는 것에 대해서 진지하게 고민했다. 협업 관련하여 여러 툴을 도입하게 되었고 여러 번의 미팅을 진행했다. 중간에 나고야를 잠깐 다녀왔다. 11월에는 주로 현장에서 고객 스터디를 진행했고, 서로의 스타일을 확인하게 되었다. 12월에는 헤어짐이 있었고, 또 한편 아이템을 바꾸고 좌충우돌 하는 시간이 있었다. 돌이켜 보면, 이리저리 많이 움직이고 여러 경험을 하였지만 막상 결과물은 탐탁치 않은 해였던 것 같다. 나의 불안함을 여기저기 움직이는 걸로 어떻게든 무마하려 했었다. 19년은 내면을 탄탄히 하는 해, 그리고 그 열매를 맺을 수 있는 해가 될 수 있도록 노력하자.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"고민","slug":"고민","permalink":"http://jeongwookie.github.io/tags/고민/"}]},{"title":"어떤 문제를 풀어야 할까?","slug":"what-makes-me-passionate","date":"2018-11-28T10:22:26.000Z","updated":"2018-12-17T10:34:20.000Z","comments":true,"path":"2018/11/28/what-makes-me-passionate/","link":"","permalink":"http://jeongwookie.github.io/2018/11/28/what-makes-me-passionate/","excerpt":"","text":"오늘은 아이템 피봇을 위한 팀 회의를 하는 날이었다. 그러나, 어떤 아이디어가 좋은 것인지 논의하던 중 상당한 충격을 받았는데.. 하나의 질문이었다. “정욱님은 어떤 문제를 좋아하세요? 어떤 문제를 풀고 싶으세요?” 놀랍게도, 나는 이에 대해서 진지하게 고민해 본적이 없었다. 질문 주신 분은 평소에도 사회적 가치가 높은 문제들에 대한 관심을 표현하고 계셨다.. 나는? 어찌 보면 내가 스타트업을 하려는 이유와도 연결되는 근본적인 질문인데 내가 이에 대한 고민을 충분히 하고 있지 않다는 사실이 충격적이었다. 지금이라도 한번 고민해 보자. 나는 어떤 문제를 풀고 싶을까? 돈이 많이 벌리는 문제일까? 개인적인 성장을 도모할 수 있는 아이템일까? 너무 모호한 말들이다. 질문을 바꿔 보았다. “내가 모든 리소스를 아낌없이 사용할 정도로 몰두하게 만드는 문제 (아이템)는 무엇일까?” 1년 전, 정말 앞뒤 가리지 않고 뛰어들어서 눈뜨고 하나의 생각밖에 안했던 경험이 있다. 어떤 점이 그렇게 매력적으로 다가온걸까? 곰곰히 생각해보니, 내가 만들고자 했던 서비스의 수혜자는 결국 나였다. 내가 겪었던 문제를 어떻게 똑똑하게 해결할까 끊임없이 고민했고, 거기서 나온 솔루션을 발전시키면서 행하는 그 과정들이 나에게 너무 짜릿한 것이었다. 고생도 많이 했지만, 그것을 상쇄할 만큼 열정을 불태울 수 있었다. 결론적으로 나는 질문 주신 동업자에게 이렇게 답변했다. “저는 제가 직접 느낀 문제를 해결해 나갈 때, 가장 저를 불태울 수 있었습니다. 어찌 보면 프로의 자세와는 거리가 멀지도 모릅니다. 겪어본 문제만을 문제 인식의 범위로 잡으면, 결국 겪어보지 않은 것은 못한다는 의미니까요. 하지만, 그만큼 관심을 집중시키고 저를 온전히 불태울 수 있는 것은 역시 경험이 축적된 분야 같습니다.” 창업 사례들을 돌이켜 보면, 많은 창업자들이 자신의 경험과 일치되는 분야에서 두각을 나타내는 경우가 많다. 내가 만약 VC라고 생각해 봐도, 창업자들의 경력과 다른 아이템으로 창업을 하고 있다면 별로 매력을 느끼지 못할 것 같다. 팀의 Story가 궁금하다고 해야 할까? 어디서 문제 인식을 하였고, 이를 해결하기 위해 어떤 노력을 하였으며, 팀의 resoruce가 그 영역과 얼마나 일치되는지 면밀히 검토할 것 같다. 나는 현재 26살이고, 카이스트에 다니는 기술경영학부 학생이다. 그런데 갑자기 음식 사업을 하겠다고 나선다면, 그 배경이 궁금하지 않을까? 만약 그 배경이 단순하게 어디서 들은 아이디어 가지고 시작한다고 했을 때는.. 애초에 시작하기도 어려울 것 같다. 개인적인 결론은, 내가 더 발전하려면 억지로라도(?) 다양한 분야에 나를 던져놔야 할 것 같다. 그래야 여기서도 구르고, 저기서도 구르면서 문제를 캐치할 것 아닌가?! 쑥쓰럽지만, 그래도 어디가서 아이디어가 부족하다는 이야기는 들은 적이 없다. 하도 문제를 캐치하는 훈련을 많이 받아서 그런가.. 심심할 때 마다 문제를 기록하고 내 나름대로 해답을 상상해 본다. 다음에 내가 팀을 꾸릴 때에도 같은 질문을 해야 겠다. “당신을 불태운 경험이 있나요? 어떤 일을 같이 하면 당신의 열정을 불태우게 할 수 있을까요?”","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"온전한 사업계획서 만들기","slug":"kaist-e5-making-ir","date":"2018-11-14T07:24:23.000Z","updated":"2018-11-23T08:47:16.000Z","comments":true,"path":"2018/11/14/kaist-e5-making-ir/","link":"","permalink":"http://jeongwookie.github.io/2018/11/14/kaist-e5-making-ir/","excerpt":"","text":"오늘은 온전한 사업 계획서를 작성하는 방법에 대해서 적어보고자 한다. 사업 계획서는 다양한 목적으로 작성한다. 정부 사업 지원, VC 미팅, 데모데이 참석 등등 그러나 사업 계획서는 꼭 이런 자리에 폼 잡으려고 작성하는 것이 아니다. 조금 더 본질적인 이유에 주목해 보자. 사업 계획서는 창업자들에게 회사의 사업 방향에 대한 기준을 잡아 준다. 건물을 지으려면 설계도가 필요하듯이, 스타트업에게 사업 계획서란 빠르게 성장하기 위한 설계도이다. 잘 잡혀있지 않으면 모두가 길을 잃게 된다. 사업 계획서는 내부 직원들에게 회사가 어떤 일을 하고 있는가에 대한 공감대를 형성한다. 외부 인사들에게 투자를 설득하기 위해서만 이를 작성하는 게 아니다. 내부부터 사업에 대한 확신과 비젼을 심어주어야 한다. 사업 계획서는 투자자와 협력사가 우리 회사와 함께 했을 때의 이익에 대해서 설득하는 도구이다. 잘 만들어진 사업 계획서는 나와 임직원, 외부조력자 모두 설득할 수 있는 문서임을 꼭 명심하자. 각각의 자리에 따라, 청중들이 듣고 싶은 내용들은 다르지만 공통적으로 원하는 항목들이 있다. 순서대로 번역해 보면, 회사(팀) 설립 목적 문제 해결책 왜 지금인가 마켓 사이즈 경쟁 업체 제품 설명 수익 모델 팀 재정 각각 한 페이지 작성을 기준으로 한다. 보통 10~15 페이지 안쪽으로 끝내면 무리없이 읽히는 사업계획서라 할 수 있겠다. 각 항목에 대한 설명은 류중희 퓨쳐플레이 대표님이 강연하신 내용을 기록한 여기를 참고하자. 본 내용으로 작성하여 발표하는 것이 이번 KAIST E5 파이널 미션의 주제 이다. 어제, 본엔젤스의 전태연 파트너님이 방문하셔서 여기와 관련되어서 이것저것 이야기를 해 주셨다. 파트너님이 하신 말씀 중에 기억에 남는 부분이 있다. 바로 투자자들의 속성을 이해해야 한다는 것. 아래는 그들의 일반적인 속성이다. (파트너님 본인도 포함된다 하셨다..ㅋㅋ) 바쁘다. 이해하기 어렵다. 생각할 시간이 없다. 시장 조사를 직접 해볼 시간이 없다. 공부할 시간이 없다. 무슨 생각이 드는가? 사업 계획서를 투자해 달라고 그들에게 가져갈때 어떻게 스토리를 구성해야 하는지 감이 잡히는가? 바빠서 생각할 시간도 없는 그들을 붙잡고, 내 사업이 얼마나 시장에서 핫한지, 왜 매력적인 아이템인지 설득해야 하는 것이다. 특히, 회사의 설립 목적 (비젼) 과 팀의 구성 에 주목한다고 한다. 아이템의 독창성 등에 집중한 팀은, 아이템이 사라지면 갈 길이 모호해 진다. 많은 초기 스타트업이 현 아이템이 벽에 부딪혔을 때 좌절하는 이유가 바로 이것이다. 하지만, 사업계획을 검토하고 투자하는 사람들은 아이템은 상황에 따라 충분히 바뀔수 있다고 생각한다. 이들은 아이템은 바뀔 수 있지만, 팀은 엔진력 있게 앞으로 나아가기를 원한다. 그래서 초기 스타트업은 아이템 보다는 팀이 얼마나 결속력 있고, 능력이 출중한지 부각해야 한다 고 조언하셨다. 초기 투자 사업 계획서는 Story of Team, 후기 투자 사업 계획서는 Story of Numbers. 실제로, 아이템은 매력도가 떨어지지만, 대표의 역량이 출중하거나 팀의 실행력에 감동 받고 아, 이팀은 뭘 해도 되겠다! 해서 투자를 집행한 경우가 많다고 한다. 실제 사업 계획서의 항목을 채워 넣을 때 어떻게 적으면 좋을지 조언해 주신 부분도 있다. Financial Plan 부분은, 성장을 숫자로 표현해야 한다. 투자금을 활용하는 방식에 대하여, 사업의 성장을 위해 필요한 자금을 명시한 후, 다음에 우리는 무엇을 할꺼다! 그래서 이런이런 돈이 필요하고, 다음 stage 까지의 도달 시간 및 완료 가능한 KPI를 제시해야 한다. 또한, 앞서 제시한 사업 계획서 목차 이외에 제시하고 싶은 도표나 자료, 혹은 예상되는 질문에 대한 답변 자료 등은 모두 appendix으로 처리하지, 발표 내용에 추가하지 않는다. 발표가 길어질 뿐더러, 핵심이 흐려서 투자자들이 집중할 수 없게 만드는 주 원인이 된다고 한다. 나도 오늘 적은 내용들을 시간 날때마다 다시 보고, 계속 사업 계획서를 수정해 나갈 것이다.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"멘탈 모델을 적용한 고객 인터뷰","slug":"kaist-e5-item-interview","date":"2018-11-06T13:06:45.000Z","updated":"2018-11-06T16:37:58.561Z","comments":true,"path":"2018/11/06/kaist-e5-item-interview/","link":"","permalink":"http://jeongwookie.github.io/2018/11/06/kaist-e5-item-interview/","excerpt":"","text":"주말동안 오랜만에 필드에서 고객 인터뷰를 진행했다. 저번 포스트에서 소개했던 KAIST E5 2차 발표의 목표가 바로 Customer Discovery. 10월 동안 우여곡절 끝에 팀원과 아이디어까지 통째로 피봇하여서 시간이 많지 않았다. 그래서 우리가 가진 지원금 100만원 가량을 통째로 쏟아부어서 양질의 데이터를 얻기로 함! 자금을 많이 투자한 만큼, 내가 경험한 그 어떠한 인터뷰 보다 체계적으로 진행하였던 것 같다. 우리 팀이 인터뷰 분석 툴로 설정한 모델은 바로 멘탈 모델 (Mental Model) 이다. 멘탈 모델이란, 인간 행위에 기반한 디자인 전략이다. 사람들의 행동 동기, 사고 과정 뿐만 아니라, 그들이 행동하는 감성적, 철학적 배경에 대해서도 깊이 이해할 수 있도록 사용자들에게서 자료를 수집하여 의미상 가까운 것 끼리 모아놓은 것이다. 위 그림을 보면 무슨 말인지 조금 감이 잡힐 거다. 멘탈 모델을 만든다는 것은, 사람들이 하는 행동에 대해 그들과 이야기하고, 패턴을 찾고, 그 패턴을 모두 포괄하는 하나의 모델로 정리하는 일이다. 우리가 인터뷰 전에 예시로 만든 질문들을 아래에 정리해 보았다. 대질문 그 과정은 어떻게 진행되었나요? 그 일은 어떤 방법으로 하셨나요? 조금 더 상세하게 설명해 주실 수 있나요? 왜 그렇게 일을 진행하셨나요? 왜 그런 결정을 하셨나요? 우선순위를 어떻게 매기셨나요? 위의 대질문은, 인터뷰이가 취한 행동을 먼저 수집하고, why? 의 질문을 통해 맥락과 감정을 읽어내려 하였다. 또한, 우선순위에 대한 질문을 추가하여 행동을 취한 당시에 사용한 도구에 대해서 자연스럽게 정보를 획득하려 하였다. 그리고 인터뷰 사이 사이에 조금 더 구체적인 정보를 얻고, 매끄러운 진행을 위해 추가 질문 또한 미리 설계하였다. 추가질문 예를 몇가지 들어주실 수 있을까요? 마지막으로 단계가 있다면 어떤 건가요? 어떤 단계를 밟는지 말씀해 주세요. 어떤 기준을 제일 중요하게 생각하시나요? 상세한 내용을 설명해 주실 수 있나요? 이러한 질문들을 통해 우리가 얻으려는 것은 바로 고객의 니즈 그 자체. 이때까지 내가 한 인터뷰들은 고객이 이럴 것이다~ 라고 가설을 몇가지 세운 후, 이를 증명하기 위해 질문을 설계한 것이었다. 그런데, 멘탈 모델에 기반한 인터뷰 방법은 마치 raw data를 쭉 수집하는 데에 집중하는 것으로 보였다. 당연하게도 bias한 결과가 나오는 것에 대해서 고민할 필요가 아예 없었다. 단순히 행동을 수집하는 데에만 집중했으니. 인터뷰 대상자를 선정하는 방법은 별개의 내용이다. (자금이 많이 들어간 이유가 있다 ㅠㅠ) 먼저, 우리의 새 아이템 target customer은 서울에 있는 대학생이다. 이들에게 접근하기 위해 서울의 각 학교별로 사용 중인 커뮤니티를 파악하고, 여기에 우리의 홍보글을 올려줄 알바(?)를 모집했다. 인터뷰 대상자에게는 40분 ~ 1시간 동안 우리 팀의 인터뷰를 성실히 임하는 대신 그 보상으로 현금 1만원과 경품 추첨으로 애플 에어팟을 지급한다는 공고를 뿌렸다. 총 150명 가량이 응답하였고, 이 중 우리의 목적에 맞도록 3가지 case로 인터뷰 대상자를 나누어 분류했다. 그리고 최종적으로 강남역과 홍대입구역에서 주말동안 인터뷰가 가능한 사람을 성별, 학교별, 나이별로 균형있게 선발하였다. 어우.. 그런데 인터뷰 자체는 매우 의미있고 재미있었지만, 체력적으로 많이 힘들었다. 주말동안 아침 10시부터 저녁까지 1시간 단위로 계속 인터뷰를 진행했으니.. 팀원들도 많이 고생해서 숙소 가니까 아무말도 못하고 바로 뻗어버렸다..ㅋㅋ 이제 인터뷰를 통해 쌓인 데이터를 분석할 일만 남았는데.. 양이 엄청니다!!! 하긴 행동을 계속 쌓아나갔으니.. 멘탈 모델에 대해서 좀 더 자세히 알고 싶다면 Adaptive Path 의 공동창업자인 Indi Young 이 쓴 책, Mental Model을 참고하자.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"파이썬 기초 완강!","slug":"python-class-accomplishment","date":"2018-10-17T05:34:23.000Z","updated":"2019-01-17T05:42:08.811Z","comments":true,"path":"2018/10/17/python-class-accomplishment/","link":"","permalink":"http://jeongwookie.github.io/2018/10/17/python-class-accomplishment/","excerpt":"","text":"2주간의 교육과 2주 이상의 실습 시간이 끝나고 얻은 수료증! 별건 아니지만, 이런 증서를 받을때는 항상 무언가 감회가 새롭다. 내가 이 교육에서 공부한 내용은 이정도 되겠다. 파이썬 문법에 대한 이해 beautifulsoup을 이용한 웹 크롤링 파이썬을 사용한 데이터 전처리 기초 아무래도 학부때 배운 프로그래밍 언어가 C다 보니, 아예 프로그래머로 전향할 것이 아닌 이상 쓰임새가 덜 하더라. 그래도 당시에 성적은 A 를 받았었는데..ㅋㅋ 이번에 배운 파이썬 기초를 바탕으로 조금씩 쌓아 나가야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"파이썬으로 주소록 만들기","slug":"python-adress-book-program","date":"2018-10-11T16:43:12.000Z","updated":"2018-10-12T05:55:08.000Z","comments":true,"path":"2018/10/12/python-adress-book-program/","link":"","permalink":"http://jeongwookie.github.io/2018/10/12/python-adress-book-program/","excerpt":"","text":"클래스를 이해하는 데에 가장 직관적인 방법으로 간단한 프로그램을 만들어 보았다. 주소록 프로젝트, 우리 스마트폰을 보면 이름, 전화번호, 이메일 등을 저장하고 관리할 수 있는 주소록 프로그램이 있는데, 파이썬을 이용해서 기본적인 로직을 구현해 보는 것으로 목표를 잡았다. 가장 먼저, Contact라는 클래스를 만드는 것 부터 시작한다. 123456789101112class Contact: def __init__(self, name, phone_number, e_mail, address): self.name = name self.phone_number = phone_number self.e_mail = e_mail self.address = address def print_info(self): print(\"Name : \", self.name) print(\"Phone number : \", self.phone_number) print(\"E-mail : \", self.e_mail) print(\"Address : \", self.address) __init__을 사용해서 name, phone_number, e_mail, 그리고 address라는 4가지 입력값을 클래스 인스턴스를 생성할 때 받도록 하였다. 또한, 입력받은 정보를 화면에 출력하기 위해 print_info라는 메써드도 정의하였다. 그리고 run()을 작성함으로써 제대로 코드가 작동함을 확인한다. 123456789101112def run(): kim = Contact('김정욱', '010-1234-5678', 'captainfox@kaist.ac.kr', 'Daejeon') kim.print_info()if __name__ == \"__main__\" run()&gt;&gt;&gt; Name : 김정욱Phone number : 010-1234-5678E-mail : captainfox@kaist.ac.krAddress : Daejeon 이제, 사용자로부터 데이터를 입력받도록 함수인 set_contact()을 정의해 보자. 1234567def set_contact(): name = input(\"Name : \") phone_number = input(\"Phone number : \") e_mail = input(\"E-mail : \") address = input(\"Address : \") contact = Contact(name, phone_number, e_mail, address) return contact 사용자에게 이름, 전화번호, 이메일, 주소를 입력 받도록 하였으며, 이를 사용하여 contact라는 객체를 생성한 후 반환하도록 하였다. run()을 수정하여 결과물을 확인한다. 123456789def run(): set_contact() print(contact)if __name__ == \"__main__\" run()&gt;&gt;&gt;김정욱 010-1234-5678 captainfox@kaist.ac.kr Daejeon #input values 이제, 주소록 프로그램의 메뉴를 만들어 보자. 크게 [연락처 입력], [연락처 출력], [연락처 삭제], [종료] 버튼으로 구성하려 한다. 1234567def print_menu(): print(\"1. 연락처 입력\") print(\"2. 연락처 출력\") print(\"3. 연락처 삭제\") print(\"4. 종료\") menu = input(\"메뉴선택 : \") return int(menu) 한번 실행된 프로그램은 [종료] 버튼을 누르기 전에는 계속 실행되어야 한다. 파이썬에서는 while 1이라는 구문을 사용하면 무한 루프를 사용할 수 있다. run()을 수정하여 4를 눌렀을 때 프로그램이 종료되도록 해보자. 1234567891011121314def run(): while 1: menu = print_menu() if menu == 4: break&gt;&gt;&gt;1. 연락처 입력2. 연락처 출력3. 연락처 삭제4. 종료&gt;&gt;&gt;4&gt;&gt;&gt; 이제, 앞서 작성했던 set_contact()을 1을 눌렀을 때 작동하도록 run()을 수정해 보자. 123456789def run(): contact_list = [] # 빈 리스트 생성 while 1: menu = print_menu() if menu == 1: contact = set_contact() contact_list.append(contact) elif menu == 4: break 이제 이 프로그램은 1을 눌렀을 때 contact라는 객체를 생성하고, 이는 contact_list라는 리스트 자료형에 append()를 통해 차곡차곡 쌓일 것이다. 2를 눌렀을 때 입력받은 연락처를 출력하도록 run()을 수정해 보자. 1234567891011def run(): contact_list = [] while 1: menu = print_menu() if menu == 1: contact = set_contact() contact_list.append(contact) elif menu == 2: print_contact(contact_list) elif menu == 4: break 이는 간단하게 print_contact()을 추가함으로써 이루어진다. 이번에는 3을 눌렀을 때 연락처를 삭제하도록 해보자. contact_list에서 name을 입력받았을 때, 해당하는 객체를 삭제하도록 하는 delete_contact()을 먼저 만들어 본다. 1234def delete_contact(contact_list, name): for i, contact in enumerate(contact_list): if contact.name == name: del contact_list[i] enumerate()함수가 쓰임에 주목하자. (사실 아직 이 함수의 동작 원리가 헷갈린다..ㅠㅠ) 이제 run()을 수정하면 되겠다. 1234567891011121314def run(): contact_list = [] while 1: menu = print_menu() if menu == 1: contact = set_contact() contact_list.append(contact) elif menu == 2: print_contact(contact_list) elif menu == 3: name = input(\"Name: \") delete_contact(contact_list, name) elif menu == 4: break 전반적인 구조와 기능은 작성이 완료되었다. 이제 프로그램의 편의를 위해 기능을 추가해 보자. 프로그램을 켜서 연락처를 등록하였는데, 종료 후 연락처가 지워진다면 곤란할 것이다. 이 문제를 해결하려면, 연락처를 등록 후 이를 저장해야 하고, 프로그램이 동작할 때 다시 불러와야 한다. 먼저 연락처 저장 기능을 담은 store_contact()부터 작성해 보자. 12345678def store_contact(contact_list): f = open(\"contact_db.txt\", \"wt\") for contact in contact_list: f.write(contact.name + '\\n') f.write(contact.phone_number + '\\n') f.write(contact.e_mail + '\\n') f.write(contact.addr + '\\n') f.close() store_contact()을 실행하면, contact_db.txt라는 텍스트 파일 안에 이름, 전화번호, 이메일, 그리고 주소가 저장된다. 이번에는 텍스트 파일로부터 정보를 로드하는 함수 load_contact()을 작성해 보자. 1234567891011121314def load_contact(contact_list): f = open(\"contact_db.txt\", \"rt\") lines = f.readlines() num = len(lines) / 4 num = int(num) for i in range(num): name = lines[4*i].rstrip('\\n') phone_number = lines[4*i+1].rstrip('\\n') e_mail = lines[4*i+2].rstrip('\\n') address = lines[4*i+3].rstrip('\\n') contact = Contact(name, phone_number, e_mail, address) contact_list.append(contact) f.close() readlines() 함수는 파일의 모든 라인을 읽어서 각각의 줄을 요소로 갖는 리스트로 반환한다. 자세한 내용은 여기를 참고하자. 각각의 contact당 4줄의 데이터가 존재하므로 4로 나눈 후 int로 반환하게 함으로써 몇 개의 연락처가 존재하는지 확인한다. 그리고 for문을 통해 쭉 읽은 데이터들을 쪼개어서 각각의 변수에 할당하는데 끝의 공백을 제거하기 위해 .rstrip()함수를 사용하였다. 위 함수의 자세한 쓰임새는 여기를 참고하자. 마지막으로, 작성한 store_contact()와 load_contact()을 run()에 적용시킨다. store_contact()은 프로그램을 종료하기 직전, load_contact()은 프로그램을 실행시킨 직후 수행되면 된다. 12345678910111213141516def run(): contact_list = [] load_contact(contact_list) while 1: menu = print_menu() if menu == 1: contact = set_contact() contact_list.append(contact) elif menu == 2: print_contact(contact_list) elif menu == 3: name = input(\"Name: \") delete_contact(contact_list, name) elif menu == 4: store_contact(contact_list) break 아래는 지금까지 작성한 주소록 프로젝트의 최종 코드이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Contact: def __init__(self, name, phone_number, e_mail, address): self.name = name self.phone_number = phone_number self.e_mail = e_mail self.address = address def print_info(self): print(\"Name : \", self.name) print(\"Phone number : \", self.phone_number) print(\"E-mail : \", self.e_mail) print(\"Address : \", self.address)def set_contact(): name = input(\"Name : \") phone_number = input(\"Phone number : \") e_mail = input(\"E-mail : \") address = input(\"Address : \") contact = Contact(name, phone_number, e_mail, address) return contactdef print_menu(): print(\"1. 연락처 입력\") print(\"2. 연락처 출력\") print(\"3. 연락처 삭제\") print(\"4. 종료\") menu = input(\"메뉴선택 : \") return int(menu)def print_contact(contact_list): for contact in contact_list: contact.print_info()def delete_contact(contact_list, name): for i, contact in enumerate(contact_list): if contact.name == name: del contact_list[i]def store_contact(contact_list): f = open(\"contact_db.txt\", \"wt\") for contact in contact_list: f.write(contact.name + '\\n') f.write(contact.phone_number + '\\n') f.write(contact.e_mail + '\\n') f.write(contact.address + '\\n') f.close()def load_contact(contact_list): f = open(\"contact_db.txt\", \"rt\") lines = f.readlines() num = len(lines) / 4 num = int(num) for i in range(num): name = lines[4*i].rstrip('\\n') phone_number = lines[4*i+1].rstrip('\\n') e_mail = lines[4*i+2].rstrip('\\n') address = lines[4*i+3].rstrip('\\n') contact = Contact(name, phone_number, e_mail, address) contact_list.append(contact) f.close()def run(): contact_list = [] load_contact(contact_list) while 1: menu = print_menu() if menu == 1: contact = set_contact() contact_list.append(contact) elif menu == 2: print_contact(contact_list) elif menu == 3: name = input(\"Name : \") delete_contact(contact_list, name) elif menu == 4: store_contact(contact_list) breakif __name__ == \"__main__\": run() 중간중간에 배웠지만 쓰임이 익숙하지 않아 찾아본 함수들도 있었고, 아예 사용하는 방법을 몰랐던 함수도 있었다. 앞으로는 위와 같은 예제 프로그램을 하나씩 작성해 보면서 지식을 메꾸어 나가는 걸로. (참고 자료 : https://wikidocs.net/3523)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"모듈과 패키지","slug":"python-module","date":"2018-10-04T12:46:51.000Z","updated":"2018-10-05T15:43:24.090Z","comments":true,"path":"2018/10/04/python-module/","link":"","permalink":"http://jeongwookie.github.io/2018/10/04/python-module/","excerpt":"","text":"코딩에서 가장 중요한 것은, 바로 남이 구현해 놓은 것을 가져다가 잘 쓰는 것이라고 배웠다. 모듈 (moudule)이란 함수나 변수 혹은 클래스 등을 뫃아놓은 파일이며, 쉽게 말하면 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만들어진 파이썬 파일이다. 다른 사람들이 이미 만들어 놓은 모듈을 사용하거나, 내가 직접 만들어서 사용할 수도 있다. 간단히 모듈을 만들고 불러와 보자. 1234567891011# my_statistics.pydef add(a,b): return a + b def sub(a,b): return a - b# my_main.py (my_statistics.py와 같은 폴더 내의 파일)&gt;&gt;&gt; import my_statistics&gt;&gt;&gt; print(my_statistics.add(10,20))30 my_statistics.py라는 모듈을 불러오기 위하여 import 를 사용하였다. 불러온 이후, 모듈 내의 함수 add를 사용하기 위해 모듈이름.함수명() 와 같이 도트 연산자를 붙였다. my_statistics.add(10,20) 조금 길지 않은가? 모듈 이름을 쓰지 않고 함수를 사용하는 방법도 있다. 12345678# my_main.py&gt;&gt;&gt; from my_statistics import sum&gt;&gt;&gt; print(sum(3,4))7&gt;&gt;&gt; from my_statistics import *&gt;&gt;&gt; print(sub(5,2))3 위와 같이 from 모듈이름 import 모듈함수 와 같은 형태를 입력하면, 그 함수를 모듈이름을 붙이지 않고 사용할 수 있다. 모듈 내 모든 함수를 불러오려면, *을 붙이면 된다. 이번에는, 앞서 만든 my_statistics.py 모듈에 몇 개의 코드를 추가해 보자. 모듈이 제대로 작동하는지 테스트를 위한 코드이다. 그리고, import를 통해 다른 파이썬 파일에서 모듈을 불러와 보자. 1234567891011121314# my_statistics.pydef add(a,b): return a + b def sub(a,b): return a - bprint(add(1,3)) # 테스트 코드print(\"my_statistics 파일입니다\") # 테스트 코드# my_main.py&gt;&gt;&gt; import my_statistics4my_statistics 파일입니다 나는 my_statistics.py 모듈 안의 add 함수와 sub 함수를 사용하려고 import했는데, 테스트 코드까지 같이 출력되어 버린다.. 이러한 문제를 방지하기 위하여, if __name__ == &quot;__main__&quot;을 사용한다. 1234567891011121314# my_statistics.pydef add(a,b): return a + b def sub(a,b): return a - bif __name__ == \"__main__\": print(add(1,3)) print(\"my_statistics 파일입니다\") # my_main.py&gt;&gt;&gt; import my_statistics&gt;&gt;&gt; import를 실행했을 때 이제는 테스트 코드가 출력되지 않음을 알 수 있다. 내가 만약 my_statistics.py을 직접 실행시킬 경우 __name__에는 __main__ 이라는 값이 저장된다. 하지만, my_main.py와 같은 다른 파이썬 파일에서 my_statistics.py을 직접 실행시킬 경우, __name__에는 my_main.py 이라는 값이 대신 저장된다. 지금까지는 작성한 모듈과 실행하고 있는 파이썬 파일이 같은 디렉토리 안에 존재하는 경우만 다루었다. 만약 내가 적당한 곳 (ex.바탕화면에 있는 python 폴더)에 py파일을 저장해 놓았는데, 이를 불러서 현재 디렉토리 내에서 사용하려면 어떻게 해야할까? 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(\"C:\\\\Users\\\\JEONGWOOK\\\\python\") sys.path는 파이썬 라이브러리들이 설치되어 있는 디렉토리를 list 자료형으로 가지고 있다. 여기다가 우리는 list 자료형 다루기에서 언급하였던 append()함수를 사용하여 요소를 추가하면 된다. 파이썬 모듈의 경로를 입력할 때, \\가 &quot; &quot; 안에서 인식되게 하기 위하여 \\\\ 이렇게 두 번 입력했음에 유의하자. 패키지 (package)는 모듈들을 묶어놓은 것으로, 폴더 형태로 생각하면 된다. 12345678910root_package/ __init__.py sub_package_1/ __init__.py module1.py module2.py sub_package_2/ __init__.py module3.py module4.py 위 구조를 예시로 살펴보면, root_package안에 sub_package_1과 sub_package_2가 있고 각각의 디렉토리 안에 모듈들이 들어 있다. 패키지 안의 모듈을 사용하려면 루트 디렉토리부터 경로를 적어주면 된다. import root_package.sub_package_1.module1 패키지의 경우 보통 많은 개발자들이 참여하는 복잡한 프로젝트의 경우에 사용한다. 그러므로 조금 더 자세한 내용을 보려면 여기를 클릭하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"구글 애드센스(Adsense) 추가하기","slug":"put-google-adsense-in-your-hexo-blog","date":"2018-10-02T05:18:51.000Z","updated":"2018-10-02T07:12:58.206Z","comments":true,"path":"2018/10/02/put-google-adsense-in-your-hexo-blog/","link":"","permalink":"http://jeongwookie.github.io/2018/10/02/put-google-adsense-in-your-hexo-blog/","excerpt":"","text":"블로그를 시작하다 보니 자연스럽게 광고에도 관심이 갔다. 아직 View 수가 많거나 방문자 수가 셀 수 없을 만큼은 안되지만, 광고를 추가하고 싶었다. 그러나 방문하신 분이 불쾌하지 않고, 본문을 읽기에 방해가 되지 않는 선에서만. 가장 유명하고, 많이 사용하는 광고 툴이 바로 구글 애드센스 (Google adsense) 홈페이지에 접속하면, 구글 계정으로 로그인 한 후, 먼저 구글 애드센스에 가입해야 한다. 광고를 등록하고자 하는 웹사이트 URL과 구글 이메일 주소를 입력하면 된다. 그 후는 통상 하는 회원가입과 비슷한데, 한 가지 유의할 점은 주소를 입력할 때 실거주지를 제대로 입력해야 한다는거! 한글로 써도 무방하다. 이 주소로 우편물이 오는데, 여기 적힌 Pin 번호를 입력해야 수익이 지급되니 주의할 것. 이까지는 참 쉽다! 하지만.. 이제부터가 시작이다 ㅠㅠ 많은 블로거들이 고생하는 구글 애드센스 계정 활성화하기, 나도 오늘까지는 안되는 줄 알았다. 필자의 경우 Hexo를 통해 블로그를 구성하고 있으며 테마는 Hueman을 사용하고 있다.(Hexo 블로그 테마 적용하기 - Eric Han님의 블로그 참고) 구글 애드센스의 안내로는 자신의 페이지의 HTML 태그 바로 뒤에 붙여넣으라 하는데.. 지금 hexo로 구성된 파일들을 보면 index.html이 여러가지 js파일을 통해 hexo generate 할 때 마다 생성되고 있었고, 여기에다가 붙여넣는 것은 의미가 없었다. 어찌어찌 검색을 통해서 알아낸 사실은, themes 폴더 안에 있는 layout 폴더에 들어가서 여기 파일 중 layout.ejs가 전체적인 레이아웃을 담당하고 있다는 것이다. 그래서 여기 &lt;body&gt; 태그 위에 코드를 그대로 붙여 넣었었다. 1234567891011121314151617181920212223&lt;%- partial('common/head') %&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;%- partial('common/header', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main-body container-inner\"&gt; &lt;div class=\"main-body-inner\"&gt; &lt;section id=\"main\"&gt; &lt;%- partial('common/content-title') %&gt; &lt;div class=\"main-body-content\"&gt; &lt;!-- 여기다가 코드 붙여넣기 --&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;/section&gt; &lt;%- partial('common/sidebar') %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%- partial('common/footer', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial('common/scripts') %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 그런데, 1주일을 넘게 기다렸는데도 승인 메일은 오지 않았다.. 그래서 뭔가 조취를 취해야 겠다고 생각했다. 블로그를 세팅할 때 많은 도움을 주신 Eric Han님의 블로그에서 다시 찬찬히 Hexo 블로그에 구글 애드센스(Adsense) 추가하기 글을 따라해 보았다. 먼저, layout 폴더 안에 ads라는 폴더를 새로 만들었다. 그리고 아까 전 layout.ejs 안에 붙어넣었던 구글 애드센스가 준 코드를 지우고, 새로 만든 ads 폴더 안에 adsense.ejs를 새로 만들어서 거기다가 코드를 붙여 넣었다. 그리고 내가 광고를 개제하고 싶은 공간에다가 모두 &lt;%- partial(&#39;ads/adsense&#39;) %&gt; 를 붙여 넣었다. 본문 상단 themes/layout/layout.ejs 파일 안의 &lt;%- body %&gt; 바로 위에 붙여넣기. 1234567891011121314151617181920212223&lt;%- partial('common/head') %&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;%- partial('common/header', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main-body container-inner\"&gt; &lt;div class=\"main-body-inner\"&gt; &lt;section id=\"main\"&gt; &lt;%- partial('common/content-title') %&gt; &lt;div class=\"main-body-content\"&gt; &lt;%- partial('ads/adsense') %&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;/section&gt; &lt;%- partial('common/sidebar') %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%- partial('common/footer', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial('common/scripts') %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 본문 하단 themes/layout/common/article.ejs 파일 안의 &lt;footer class=&quot;article-footer&quot;&gt; 바로 위에 붙여넣기. 12345678910111213141516171819202122232425&lt;article id=\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\" class=\"article article-single article-type-&lt;%= post.layout %&gt;&lt;%= (post.direction &amp;&amp; post.direction.toLowerCase() === 'rtl' ? ' rtl' : '') %&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;div class=\"article-inner\"&gt; &lt;% if (post.link || post.title) &#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123; class_name: 'article-title' &#125;) %&gt; &lt;/header&gt; &lt;% &#125; %&gt; &lt;% if (post.layout != 'page') &#123; %&gt; &lt;div class=\"article-meta\"&gt; &lt;%- partial('post/date', &#123; class_name: 'article-date', date_format: null &#125;) %&gt; &lt;%- partial('post/author') %&gt; &lt;%- partial('post/tag') %&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;%- partial('post/gallery') %&gt; &lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;%- post.content %&gt; &lt;/div&gt; &lt;%- partial('ads/adsense') %&gt; &lt;footer class=\"article-footer\"&gt; &lt;%- partial('share/index', &#123; post: post &#125;) %&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/article&gt;&lt;%- partial('comment/index') %&gt; 사이드바 themes/layout/common/sidebar.ejs 파일 안의 제일 아래 &lt;/aside&gt; 바로 위에 붙여넣기. 123456789101112131415161718192021222324252627282930&lt;aside id=\"sidebar\"&gt; &lt;a class=\"sidebar-toggle\" title=\"Expand Sidebar\"&gt;&lt;i class=\"toggle icon\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;div class=\"sidebar-top\"&gt; &lt;p&gt;&lt;%= __('sidebar.follow') %&gt;:&lt;/p&gt; &lt;ul class=\"social-links\"&gt; &lt;% for (var i in theme.customize.social_links) &#123; %&gt; &lt;% if (theme.customize.social_links[i]) &#123; %&gt; &lt;li&gt; &lt;a class=\"social-tooltip\" title=\"&lt;%= i %&gt;\" href=\"&lt;%- url_for(theme.customize.social_links[i]) %&gt;\" target=\"_blank\" rel=\"noopener\"&gt; &lt;i class=\"icon fa fa-&lt;%= i %&gt;\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"github-card\" data-github=\"jeongwookie\" data-width=\"\" data-height=\"\" data-theme=\"default\"&gt;&lt;/div&gt; &lt;script src=\"//cdn.jsdelivr.net/github-cards/latest/widget.js\"&gt;&lt;/script&gt; &lt;% if (is_post()) &#123; %&gt; &lt;%- partial('post/nav', &#123;post: page&#125;) %&gt; &lt;% &#125; %&gt; &lt;div class=\"widgets-container\"&gt; &lt;% if (theme.widgets) &#123; %&gt; &lt;% theme.widgets.forEach(function(widget) &#123; %&gt; &lt;%- partial('widget/' + widget, &#123;post: page&#125;) %&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;%- partial('ads/adsense') %&gt;&lt;/aside&gt; 그리고 hexo g --d를 입력하면 끝! adsense.ejs에 작성한 코드는 구글 애드센스가 준 페이지 확인 코드이기 때문에, 따로 generate 시 제대로 적용 되었는지 확인할 방도가 없다.. 나도 이렇게 해놓긴 했는데 제대로 된건지 안된건지 알수가 없어서 그냥 그대로 방치(?)했는데, 이렇게 세팅한지 2주 가까이 되었나? 거의 까먹어 갈 때 즈음 메일이 왔다. 참고로 승인이 날 동안 블로그의 방문자수는 거의 0에 수렴하였고, 게시글의 숫자도 20개가 채 안되었었다. 블로그 게시물 숫자나 방문자 수가 승인 기준이 아니라, 그냥 제대로 된 곳에 코드를 잘 붙여놓고 인내심을 가지면 해결되는 문제인 것 같다. 승인 이후에는 매우 쉽다. 승인된 계정으로 다시 한번 애드센스 홈페이지에 접속하고, 내 광고 &gt; 콘텐츠 &gt; 광고 단위 메뉴에 들어가서 새 광고를 만들면 된다. 등록을 완료하면, 고유 코드가 생성되는데 이것을 복사한다. 그리고 앞서 만들어놓은 themes/layout/ads/adsense/ejs 파일 안에 있는 구글 애드센스 계정 등록 시 사용되었던 코드를 깨끗하게 지우고, 여기다가 붙여 넣으면 된다. 필자와 똑같이 하면, 구글 애드센스 광고가 본문 상단, 본문 하단, 그리고 사이드바에 성공적으로 위치함을 확인할 수 있다. 조금 더 상세한 정보를 알고 싶다면 Eric Han’s Blog 를 참고하자.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/categories/Hexo/"}],"tags":[{"name":"블로그 issue","slug":"블로그-issue","permalink":"http://jeongwookie.github.io/tags/블로그-issue/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/tags/Hexo/"},{"name":"Google Adsense","slug":"Google-Adsense","permalink":"http://jeongwookie.github.io/tags/Google-Adsense/"}]},{"title":"파이썬에서 클래스 쉽게 다루기","slug":"python-class","date":"2018-09-29T16:25:25.000Z","updated":"2018-09-29T18:17:50.058Z","comments":true,"path":"2018/09/30/python-class/","link":"","permalink":"http://jeongwookie.github.io/2018/09/30/python-class/","excerpt":"","text":"오랜만의 포스트. 추석동안 집에 다녀오고, 돌아와서는 이것저것 일하다 보니 벌써 주말이다. 세 번째 섹션부터 배우기 시작한 클래스는 우리의 단순 노동 작업을 크게 줄여주고, 코드를 깔끔하게 해 주는 효자다. 찬찬히 배운 내용을 정리해 보겠다. 클래스는 붕어빵 틀이다. 일종의 틀로, 똑같은 무언가를 만들어 낼 수 있는 도면과 같은 것이다. 객체는 클래스라는 틀에 의해 생성된 구체적인 어떤 것을 칭한다. 간단하게 예제를 통해서 클래스의 기본 구조에 대해 먼저 이해해 보자. 123456789101112class FourCal: # 클래스명 \"FourCal\" 선언 def setdata(self, first, second): # 매개변수 선언 self.first = first self.second = second&gt;&gt;&gt; a = FourCal() # 객체 \"a\" 생성 (FourCal의 인스턴스)&gt;&gt;&gt; a.setdata(4,2) # 입력값 4와 2 전달&gt;&gt;&gt; print(a.first)4&gt;&gt;&gt; print(a.second)2 파이썬에서 클래스를 다룰 때, 매개변수에 self를 포함시켜야 함에 주의하자. 아래의 그림을 보면 그 구조를 파악하기 쉬울 것이다. 참고 : 파이썬 위키 이제 이 기본 지식으로 하나하나 클래스를 구현해 볼 것이다. 지금부터 내가 게임 개발자라고 가정해 보자. 다음과 같은 임무가 주어졌다. 기사, 마법사, 궁수 캐릭터를 만들어라. 각각의 캐릭터는 레벨, 이름, HP가 있다. 각각의 캐릭터는 좌우, 앞뒤로 움직일 수 있다. 각각의 캐릭터는 공격을 할 수 있다. 마법사는 마법을 쓸 수 있다. 먼저 기사 클래스부터 만들어 보자. 123456789101112131415161718192021class Knight: level = 20 name = \"Battery\" hp = 200 def move(self, direction): print(direction + \"방향으로 이동합니다\") def attack(self): print(self.name + \"이(가) 공격합니다\")&gt;&gt;&gt; knight1 = Knight() # knight1 객체 선언 (클래스명 Knight의 인스턴스)&gt;&gt;&gt; print(knight1.level, knight1.name, knight1.hp)20 Battery 200&gt;&gt;&gt; knight1.move(\"왼쪽\")왼쪽방향으로 이동합니다&gt;&gt;&gt; knight1.attack()Battery이(가) 공격합니다 위에서 level, name, hp 등의 클래스 안에서 변수를 지정하는 것을 클래스 변수 라고 한다. 멤버 변수라고도 부른다. 위 코드에 따르면, Knight 클래스에 의해서 생성된 인스턴스들은 기본적으로 지정된 클래스 변수 값을 가진다. 기사 직업을 가진 유저가 어디 한둘 이겠는가? 객체를 생성할 때 바로바로 클래스 변수를 설정할 수 있도록 객체 변수를 설정해 보자. init() 은 객체를 생성할 때 호출되는 함수이다. 여러가지 클래스 변수들을 객체가 생성될 때 설정할 수 있게 해준다. 이번에는 기사 말고 마법사 클래스를 객체 변수를 사용하여 예시로 만들어보자. 12345678910111213141516171819202122232425262728class Wizard: def __init__(self, level, name, hp): # 4개의 객체 변수 지정 self.level = level self.name = name self.hp = hp def move(self, direction): print(direction + \"방향으로 이동합니다\") def attack(self): print(self.name + \"이(가) 공격합니다\") def magic(self): print(self.name + \"이(가) 마법을 사용합니다\")&gt;&gt;&gt; wizard1 = Wizard(30, Bloodtrail, 150) # wizard1 객체 생성&gt;&gt;&gt; print(wizard1.level, wizard1.name, wizard1.hp)30 Bloodtrail 150&gt;&gt;&gt; wizard1.move(\"위쪽\")위쪽방향으로 이동합니다&gt;&gt;&gt; wizard1.attack()Bloodtrail이(가) 공격합니다&gt;&gt;&gt; wizard1.magic()Bloodtrail이(가) 마법을 사용합니다 코드를 짜다보니 앞서 작성한 기사 클래스와 겹치는 부분이 많다. (짜증) 그리고 이렇게 각각의 클래스를 작성하면, 객체 변수를 하나 추가하고 싶을 경우 클래스 3개를 수정해야 하는 불상사가 발생하게 된다.. 지금은 클래스가 3개라서 다행이지만, 만약 클래스가 100개라면? 이런 경우, 우리는 상속이 추가된 클래스 구조를 생각해야 한다. 상속이란, 부모 클래스에 이미 구현되어진 클래스 변수와 함수를 자식 클래스가 받아서 사용하는 것을 의미한다. 위 예제 코드에서 반복되는 부분을 부모 클래스로 구성해 보자. 1234567891011class Character: def __init__(self, level, name, hp): # 반복되는 클래스 변수 self.level = level self.name = name self.hp = hp def move(self, direction): # 반복되는 클래스 함수 1 print(direction + \"방향으로 이동합니다\") def attack(self): # 반복되는 클래스 함수 2 print(self.name + \"이(가) 공격합니다\") Character 이라는 클래스를 새로 만들고, 기사, 마법사, 궁수 클래스를 만들 때 공통적으로 포함되는 클래스 변수와 클래스 함수들을 집어 넣었다. 이제 이 부모 클래스를 사용해서 자식 클래스를 구성해 보자. 12345678910111213141516171819202122class Knight(Character): # 부모 클래스인 Character을 사용 passclass Archer(Character): passclass Wizard(Character): def magic(self): print(self.name + \"이(가) 마법을 사용합니다\")&gt;&gt;&gt; knight_user = Knight(20, \"Battery\", 200) wizard_user = Wizard(30, \"Bloodtrail\", 150) archer_user = Archer(15, \"CashIsK1ng\", 100)&gt;&gt;&gt; knight_user.move(\"오른쪽\")오른쪽방향으로 이동합니다&gt;&gt;&gt; wizard_user.magic()Bloodtrail이(가) 마법을 사용합니다&gt;&gt;&gt; archer_user.attack()CashIsK1ng이(가) 공격합니다 클래스의 상속 관계를 잘 설정해 놓으면, 이렇게 깔끔하게 코드가 완성된다. 차후 MP, 마지막으로 접속한 시간 등의 변수를 추가할 때에도 부모 클래스인 Character만 수정하면 모든 자식 클래스에 제대로 적용될 것이다. 클래스 작성에 익숙해지자!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"두 번째 숙제 - 반복문","slug":"second-homework-python","date":"2018-09-21T10:02:35.000Z","updated":"2018-09-21T10:53:31.000Z","comments":true,"path":"2018/09/21/second-homework-python/","link":"","permalink":"http://jeongwookie.github.io/2018/09/21/second-homework-python/","excerpt":"","text":"1번 문제 : 등차수열 형태로 별 쌓기 첫 번째 문제는 *을 1개, 아래는 2개, 3개 … 이런 식으로 쌓는 것이 목적이다. 결과물은 왼쪽 정렬된 형태인 ‘계단 모양’을 띄어야 한다. 1) 이중 for문을 사용하여 출력하기 12345678910for i in range(5): # index : i and j for j in range (i+1): if j == i: print(\"*\"*(j+1), end=\"\\n\") # end 함수는 바로 뒤의 print에 영향을 줌*************** 여기서 end=”\\n”의 의미는, print에 의해 결과값을 출력한 후 마지막에 ‘줄바꿈’하기. end=”” 이런 식으로 사용해서 print 의 결과값을 계속 붙여 나갈수도 있다. 2) 하나의 for문을 사용하여 출력하기 12345678for k in range(5): print(\"*\"*(k+1))*************** 2번 문제 : 문자열의 모든 인덱스를 리스트에 넣는 코드 만들기 두 번째 문제는 원하는 문자열을 입력 받은 후, 인덱스를 찾고 싶은 문자를 입력하면 찾아주는 코드를 짜는 것이다. 예를 들어, “string”을 입력하고 “t”를 입력할 경우, 1이 출력되어야 한다. 1234567891011121314151617input_string = input(\"원하는 문자열을 입력하시오 : \") # 문자열 입력받기print(\"입력한 문자열은 &#123;&#125; 입니다.\\n\".format(input_string))input_character = input(\"인덱스 찾기를 원하는 문자를 입력하시오 : \") # 문자 입력받기print(\"입력한 문자는 &#123;&#125; 입니다.\\n\".format(input_character))index_lst = [] # 비어 있는 인덱스 리스트 만들기for i, chr in enumerate(input_string): # enumerate() 함수 사용 if chr == input_character: index_lst.append(i)print(\"&#123;&#125;의 index는 &#123;&#125; 입니다.\".format(input_character, index_lst))&gt;&gt;&gt; input : jeongwook입력한 문자열은 jeongwook 입니다.&gt;&gt;&gt; input : w입력한 문자는 w 입니다.w의 index는 5 입니다. 여기서 enumerate() 함수가 사용되었다. enumerate는 “열거하다”라는 뜻으로, 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴하게 된다. 위의 예시에서는 input_string (문자열)을 입력받아, 인덱스값 (i)와 문자 (chr)가 함께 있는 객체를 for문에 의하여 가지고 있게 되었다. 이처럼 enumerate() 함수는 주로 for문 안에서 객체의 위치를 알고 싶을 때 자주 사용한다. 3번 문제 : 가운데 정렬로 별로 된 탑 쌓기 세 번째 문제는 *을 1개, 3게, 5개 … 이렇게 쌓아서 가운데 정렬 후 출력하는 것이 목표이다. 1) 이중 for문을 사용하여 출력하기 12345678910for i in range(5): for j in range(5-i): if j == (4-i): print(\" \"*(j) + \"*\"*(2*i+1) + \" \"*(j)) * *** ***** ******* ********* 반복문을 사용하여, 빈칸 + 별모양 + 빈칸 이런 식으로 구성 후 출력하였다. 2) 하나의 for문을 사용하여 출력하기 12345678for k in range(6): print(\"&#123;:^9&#125;\".format(\"*\"*(2*k-1))) # 빈칸 9개에서 *을 가운데 정렬 * *** ***** ******* ********* 여기서는 앞서 배웠던 format 함수를 사용한 ‘가운데 정렬’을 사용하였다. 4번 문제 : 숫자 맞추기 게임 마지막 문제는 1부터 100 사이의 숫자를 하나 랜덤하게 생성하고, 이를 맞추는 게임을 짜는 것이다. 숫자를 하나 생성하고, 그 다음 사용자가 숫자를 입력하면 이 둘을 비교하여 ‘높음’, ‘낮음’, ‘맞췄다’를 출력해야 한다. 또한, 몇 번의 guess 끝에 답을 맞췄는지 시도한 횟수를 값으로 출력해야 한다. 12345678910111213141516171819202122232425262728293031323334353637import randomselected_number = random.randrange(1,101)print(\"1부터 100까지 수 중에서 랜덤하게 생성된 숫자는 &#123;&#125; 입니다.\\n\".format(selected_number))input_number = int(input(\"1부터 100까지 수 중에서 하나를 선택하여 입력하시오 : \"))print(\"입럭한 숫자는 &#123;&#125; 입니다.\\n\".format(input_number))trial = 0while True: trial += 1 if input_number &gt; selected_number: print(\"높습니다\\n\") input_number = int(input(\"숫자를 다시 입력하세요 : \")) elif input_number &lt; selected_number: print(\"낮습니다\\n\") input_number = int(input(\"숫자를 다시 입력하세요 : \")) else: print(\"맞췄습니다!\\n\") breakprint(\"당신은 &#123;&#125; 번 만에 숫자를 맞췄습니다.\".format(trial))&gt;&gt;&gt; 1부터 100까지 수 중에서 랜덤하게 생성된 숫자는 16 입니다.&gt;&gt;&gt; 1부터 100까지 수 중에서 하나를 선택하여 입력하시오 : 21입럭한 숫자는 21 입니다.높습니다&gt;&gt;&gt; 숫자를 다시 입력하세요 : 15낮습니다&gt;&gt;&gt; 숫자를 다시 입력하세요 : 18높습니다&gt;&gt;&gt; 숫자를 다시 입력하세요 : 16맞췄습니다!당신은 4 번 만에 숫자를 맞췄습니다. 여기서 하나 주목할 점은 random 함수 이다. 처음에 import random을 통해 모듈을 불러왔고, 이를 통해서 random.randrange()와 같은 함수를 사용할 수 있게 되었다. 이름에서 알 수 있듯이, 이 함수는 (x,y)를 입력하면 x이상 y미만의 범위 내에서 랜덤하게 숫자를 하나 생성하는 기능을 가진다. 모듈의 경우 다음 포스트에서 다룰 예정이다. 지금까지는 매우 쉽다! 확실히 C언어 하다가 파이썬으로 비슷한 결과물을 짜보니 난이도가 확 떨어진 게 체감이 된다 ㅋㅋ","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"건전한 소비 습관, 적금 들기","slug":"recommend-saving-account","date":"2018-09-21T08:53:56.000Z","updated":"2018-09-21T09:54:12.000Z","comments":true,"path":"2018/09/21/recommend-saving-account/","link":"","permalink":"http://jeongwookie.github.io/2018/09/21/recommend-saving-account/","excerpt":"","text":"부모님께서 항상 하시는 말씀이 있다. 작은 돈을 받을 때부터 조금씩이라도 돈을 모으는 습관을 가져야 한다고. 사실 지금까지를 고백하자면, 돈을 받는 족족 쓰기만 했지 한푼도 모아본 적이 없다. 얼마 안되는 돈, 모아봤자 얼마나 모으겠냐는 부모님께서 들으시면 괘씸한(?) 심리와 나중에 월급 받으면 모으기 시작하면 되지! 하는 안일한 심리가 합쳐진 결과. 하지만 이 글을 쓰는 순간에도 내 마음속 깊은 곳에는.. 돈 쓰는 만큼 더 많이 벌면 되지! 하는 변명이 꿈틀거린다. 맞다. 내가 돈 많이 벌면, 그만큼 쓰는 것이 시장에도 도움이 된다. 건전한 소비 생활이라는 건데, 팩트는 내가 지금 돈을 벌고 있지 않은 학생이라는 거다.. 이런 내가 돈을 모아야겠다는 생각이 든 건 다름 아닌 네이버의 김정호 대표님 이야기 때문이다. 대표님은 삼성에 9년 다닐 동안, 월급의 100%을 적금으로 넣었다고 한다. 대단한 소비 습관이다. 보통 사람이라면 사리가 나올 것 같은.. 하지만 나는 대표님의 이야기에서 그의 절약에 대해 감동 받은 것이 아니다. 잘나가는 삼성을 때려 치고 네이버를 창업하겠다는 결단력, 그리고 힘들때 버티는 인내력이 그의 평소 소비 습관에서 나온 것 같다는 느낌이 들었기 때문이다. 결국은 앞으로 닥칠 수도 있는, 아직은 보이지 않는 위험에 대해서 자신이 할 수 있는 방법으로 똑똑하게 대처한 것이다. 창업할 때, 요즘은 지원 받을 수 있는 돈이 많다. 하지만, 작게는 법인을 세우면서 팀원들끼리 지분을 나눌때부터 위기 상황에 회사에서 돈이 나오지 않는 경우 버티는 것까지, 여윳돈은 항상 필요하다. 돈이 최고는 절대 아니지만, 돈이 없으면 괴로운 일들이 많다. 그래서 결론은! 적금을 알아보다가 우리은행에서 18년 8월 따끈따끈하게 출시한 스무살 우리 적금을 발견했다. 평소, 적금 상품에 대해서 관심이 없어 관련 지식은 적지만 딱 봐도 최고 연 3.7% 금리 조건은 꽤나 만족스럽게 보였다. 간략히 설명하자면, 매월 지정한 금액을 입금하는 정기적금과 조금씩 내가 원하는 만큼 금액을 입금하고 중도 인출도 가능한 자율적금 이렇게 두가지가 있었다. 이름이 ‘스무살 우리 적금’ 이므로 당연히 대상자는 만 18세부터 만 30세까지. 정기와 자율 모두 기본금리 연 2.6%부터 시작해서 우리카드 월 10만원 이용 시 최고 0.5% 추가, 그리고 자동이체를 통한 납입 시 최고 0.6% 우대 금리를 받을 수 있더라. 조금 더 자세한 안내를 받으려면 우리은행 상품 페이지 및 가까운 지점을 찾아가서 상담을 받아 보자. 나는 상담 받으러 가기는 귀찮아서 인터넷으로 후기 좀 찾아보고, 스마트폰으로 가입했다. 이미 우리은행을 사용하고 있었기 때문에, 우리은행 원터치개인 App이 깔려 있었고, 여기서 금융상품 -&gt; 예금/신탁을 누르면 찾을 수 있다. 내가 가입한 플랜은 정기적금으로, 1년동안 200만원 모으기 버튼을 클릭해서 연 3.5% 금리를 보장받았다. 한달에 16만 5천원을 자동이체하고, 12개월이 끝나면 대략 220만원이 조금 넘는 금액을 받는다. 또 플랜들을 보니까 욕심이 발동해서 2년동안 400만원 모으기, 3년동안 700만원 모으기에 눈길이 계속 갔지만.. 처음 적금이란 것을 내 손으로 드는 거라 작게 작게 시작해 보자고 욕심을 억눌렀다..ㅋㅋ","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"추천 아이템","slug":"Diary/추천-아이템","permalink":"http://jeongwookie.github.io/categories/Diary/추천-아이템/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"추천 아이템","slug":"추천-아이템","permalink":"http://jeongwookie.github.io/tags/추천-아이템/"}]},{"title":"파이썬으로 함수 다루기","slug":"function-in-python","date":"2018-09-19T15:25:57.000Z","updated":"2018-09-19T16:42:23.638Z","comments":true,"path":"2018/09/20/function-in-python/","link":"","permalink":"http://jeongwookie.github.io/2018/09/20/function-in-python/","excerpt":"","text":"함수 (Function)가 무엇인지는 우리 모두 알고 있다. 함수를 사용하는 이유가 무엇일까? 기본적으로 프로그래머란 종족들은 귀찮음을 최소화 하고 어떻게든 꿀(?)을 빨려고 한다. 중복되는 코드는 절대 작성하지 않는다는 뜻. 반복되는 부분이 있을 경우, 이를 그룹화 하여 함수로 만들고, 나중에 또 쓰고 싶을 때 한줄로 해결해 버린다. 결과적으로 코드의 양이 줄어들겠지? 이러한 함수화는 프로그램의 흐름을 명확하게 하는 순기능이 있다. 이제 우리의 본분으로 돌아가서, 파이썬에서의 함수 사용 방법을 알아보자. 함수의 구조는 아래와 같다. 1234def 함수이름(매개변수): &lt;수행할 문장&gt; ... return 결과값 근데 이렇게 보면 감이 잘 안오니까 예시를 실행 해 보자. 1234567891011def sum(a, b): # 함수 이름은 sum이고 매개변수는 a와 b result = a + b return result # 결과값 result 반환&gt;&gt;&gt; value = sum(3,4)&gt;&gt;&gt; print(value)7&gt;&gt;&gt; value_2 = sum(a=3, b=7) # 매개변수 지정&gt;&gt;&gt; print(value_2)10 함수를 작성할 때 위와 같은 방법이 정석이지만, 매개변수 자리를 비워 놓거나 return 값 지정을 안해줘도 돌아간다. 그런데, 입력값이 몇 개가 될지 모를 때는 어떻게 해야 할까? 위의 예제는 매개변수가 a와 b이므로 입력값이 2개로 지정되어 있는데.. 파이썬에서는 “*”을 이용한다. 123456789def my_sum(*args): # args는 임의의 변수명 sum = 0 for i in args: # 여러 개 입력 시 tuple로 들어감 sum = sum + i return sum&gt;&gt;&gt; result = my_sum(1,2,3,4,5)&gt;&gt;&gt; print(result)15 위의 예시처럼 변수명에 *을 붙이면 여러 개를 입력할 수 있게 된다. 지금까지는 함수의 입력값에 초점을 두었다면, 이제부터는 return에 대해서 알아보자. 파이썬에서 함수의 결과값은 언제나 하나이다. 1234567def sum_sub(a,b) return a+b # 여기서 함수가 종료됨 return a-b &gt;&gt;&gt; result = sum_sub(3,2)&gt;&gt;&gt; print(result)5 즉, 함수는 return문을 만나는 순간 결과값을 반환하고 종료된다. return의 이러한 성질을 사용해서 다른 방법으로 응용이 가능하다. 1234567def say_my_name(name): if name == \"\" return print(\"제 이름은 &#123;&#125; 입니다.\".format(name))&gt;&gt;&gt; say_my_name(\"김정욱\")제 이름은 김정욱 입니다. 이처럼 return을 단독으로 쓰면 함수를 즉시 빠져나갈 수 있다. 이번에는 조금 다른 형태의 입력값을 알아보자. 12345678910111213141516171819202122def say_myself(name, old, man=True): print(\"제 이름은 &#123;&#125; 입니다.\".format(name)) print(\"나이는 &#123;&#125; 살 입니다.\".format(old)) if man: print(\"남자입니다.\") else: print(\"여자입니다.\")&gt;&gt;&gt; print(say_myself(\"김정욱\", 26))제 이름은 김정욱 입니다.나이는 26 살 입니다.남자입니다.&gt;&gt;&gt; print(say_myself(\"김정욱\", 26, True))제 이름은 김정욱 입니다.나이는 26 살 입니다.남자입니다. # 위와 동일한 출력값&gt;&gt; print(say_myself(\"이하린\", 20, False))제 이름은 이하린 입니다.나이는 20 살 입니다.여자입니다. # 매개변수 False 출력값 man=True와 같이 매개변수에 미리 값을 넣어준 경우, 따로 입력하지 않아도 자동으로 True값으로 고정된다. 그래서 두 가지 결과값이 동일하게 출력된 것이다. man 변수에 False 값이 전달된 경우, if-else문에 의하여 출력값이 바뀌었음을 확인할 수 있다. 마지막으로, 함수 사용 시 주의할 점을 소개한다. 123456a = 1def test(a): a = a +1&gt;&gt;&gt; print(a)1 자칫 하다가는 결과값이 2라고 착각할 수 있다. 왜 이럴까? 함수 밖의 변수와 함수 안의 변수가 a로 이름이 똑같아서 혼란을 발생시킨 것이다. 함수 안의 매개변수는 함수 안에서만 사용되는 함수만의 변수 임에 유의하자. 그냥 global 변수와 이름을 구별되게 지으면 문제는 해결된다.. 수업 시간에 강사님께서 매우 강조하셨다. 함수는! 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"우리 서비스의 시장 크기는 얼마나 될까?","slug":"customer-discovery-kaist-e5","date":"2018-09-18T13:59:02.000Z","updated":"2018-09-19T16:48:41.277Z","comments":true,"path":"2018/09/18/customer-discovery-kaist-e5/","link":"","permalink":"http://jeongwookie.github.io/2018/09/18/customer-discovery-kaist-e5/","excerpt":"","text":"아닛..!! 저번주에 참여했던 KAIST E5 에서 놀랍게도 상금을 받으면서 2차 미션 대상팀이 되었다. 아무래도 주제가 좋지 않았나 싶다. 아직 많이 부족하지만.. 아무튼 그래서 오늘은 2차 Mission 인 Customer Discovery 강의를 들으러 KAIST 스타트업 스튜디오 1층으로 모였다. 저번 비즈니스 모델링은 카카오벤처스 김기준 상무님께서 강연해 주셨고, 이번에는 씨엔티테크 전화성 대표님께서 직접 방문하셨다. 이번 2차 미션의 목표는, 1차 캠프에서 설계한 우리의 비즈니스 모델이 정말 시장에서 통하는지 그 가설을 검증하는 것이다. 대표님께서 처음 강연 시작 전, 시장에 관하여 짧고 굵게 정의하셨는데 대단히 인상깊다. 시장, 길게 설명할 것 없어. 나한테 돈을 주는 사람들의 집합이지. 고객을 발견하는 일련의 과정은, 결국 내가 제시한 해결책이 효과적임을 입증하는 수단이다. 이를 세 가지 프로세스로 요약할 수 있다. 진짜 공감되는 문제인가? (마켓의 문제를 입증하기) 내가 제시한 솔루션이 효과적인가? 1번과 2번의 결과를 보았을 때, 내가 뛰어들 마켓의 사이즈는 이정도다! 그러면 구체적으로 위와 같은 의문을 어떻게 해결해야 할까? 내가 돈 받을 사람한테 직접 가서 알아보는 수 밖에 없다!무엇이 힘든지, 얼마나 힘든지, 내가 이런 서비스를 만들껀데 어떤 기능이 당신에게 큰 도움이 될지 등 고객과의 Deep interwiew를 진행해야 한다. 시장 규모 추정은 사업 계획서에 반드시 들어가는 항목이다. 그런데 의문이 들지 않는가? 내가 생각하는 서비스는 새로운 건데, 시장을 도데체 어떻게 숫자로 표현하라는 거지? 이를 제시하기 위한 유명한 툴이 있긴 하다. TAM (Total Addressable Market)은 한국말로 전체 시장이다. 제품 및 서비스와 관련된 전체 시장의 규모를 뜻한다. 예를 들어, 모바일 APP의 경우, 국내 스마트폰 사용자 전체 4000만명이 전체 시장 규모일 수 있겠다. SAM (Service Available Market)은 한국말로 유효 시장이다. 우리 서비스가 추구하는 비즈니스 모델이 있는 영역만을 타겟팅 한 것인데, 예를 들어 모바일 헬스케어 스타트업인 경우, 자료를 보니 전체 사용자 중 1/4가 모바일 헬스케어를 이용한다고 나와 있으므로 1000만명이다. 제일 중요한건 SOM (Serviceable Obtainable Market)인데 한국말로 수익 시장이다. 쉽게 말하면 유효 시장 안에서 우리 서비스가 초기에 노릴 수 있는 고객이 몇명인가? 에 대한 답변이다. 누가 너의 초기 서비스에 재화를 지불할 것인가? 위의 시장 규모 추정법에 대해 자세히 알고 싶은 사람은 여기를 참고하자. 나에게 대단히 도움을 많이 주고 계신 로아인벤션랩의 김진영 대표님께서 운영하시는 스타트업 관련 정보 플랫폼이다. 딱 보면 알겠지만, 결국 수익 시장을 어떻게 잡느냐가 초기 스타트업의 성패를 좌우하게 된다. 그런데, 말이 쉽지 이걸 특정하기는 대단히 어렵다.. 이 때, 괜히 없는 자료 뒤적거리지 말고 사무실 밖으로 나가보면 어떨까. (어짜피 새로운 시도를 할꺼라면 자료가 없을 꺼다) 이 말씀을 하신 분이 바로 Lean Startup의 창시자, Steve Blank 선생님 되시겠다. 고객을 특정 지으려면, 먼저 고객을 만나서 진짜 그들이 겪는 문제를 들어봐야 한다. 그러니까 사업계획서에 수익 시장을 적어 넣으려면 고객을 만나야 한다는 거다. 전화성 대표님께서 말씀해 주신 프로세스가 있다. (그리고 이것이 2차 Mission 발표일에 꼭 들어가야 한다!) 누구한테 팔껀지 가정을 하고, 그 고객한테 찾아간다. 내가 설정한 “문제”를 실제로 그들이 심각하게 겪고 있는지 검증한다. 내가 설계한 “해결책”을 제시하고, 돈을 지불할 의향이 있는지 물어본다. 2번 단계에서 많은 초기 스타트업 팀은, 그들이 생각하기에 심각한 문제 였던 것이 실제로는 별 거 아님을 깨닫는다. 이 때, 내가 생각하기에 방향이 두가지 정도 있는 것 같은데 첫 번째는 이들한테 인터뷰를 하면서 진짜 심각한 문제를 새로 캐치해 내는 것. 두 번째는 내가 설정한 심각한 문제를 겪을 만한 고객을 다시 물색하는 것. 두 가지 다 해볼만 하다. 빨리빨리 움직여 봐야 할 것이다. 또 하나, 3번 단계에서 조금 주의해야 할 사항이 있다. 고객들은 속마음을 이야기하지 않는다. 특히, 열심히 자신의 사업에 대해 이야기하는 사람을 앞에 두고 아 정말 쓸모없네요 라고 말하는 사람이 과연 몇이나 될까? 게다가 아는 사람들한테 물어보면 더 그렇다. 인터뷰도 스킬이다. 고객을 끄덕이는 것은 우리가 원하는 반응이 아니다. 진짜 매력도를 느끼는 기능이 무엇인지 캐내야 한다. 지금 단계에서 고객들이 이야기하는 “괜찮네요” 가 당신한테 그 서비스를 구매하기 위해 돈을 지불하겠다는 것과 다름을 염두에 두자. 사람들의 지갑에서 돈을 꺼내는 건 진짜로 힘든 일이다.여기서 스티브 잡스 (Steve Jobs) 의 이야기를 꺼내는 사람들이 있을 수 있겠다. 잡스 형님께서 당당하게 하신 말씀. 나는 아이폰 만들때 시장 조사를 하지 않았다. 고객들은 자신들이 원하는 게 뭔질 모르니까. 요점은 아이폰을 만들 때 자신의 직관에 의존하였다는 것인데.. 직관에 의존할 만큼 당신은, 당신이 만들 서비스가 속한 영역에 경험치가 쌓여 있는가? 스티브 잡스는 컴퓨터를 작게 만드는 데 평생을 미쳐 있었다. 25년동안 쌓은 경험들이 그의 직관을 구성했고, 이는 보통 사람들의 생각을 아득히 뛰어넘은 것이었다. 실제로 그 사이에 애플은 많은 삽질을 했다. 그들이 만든 애플 컴퓨터는 소수의 매니아층을 만족시킬 뿐이었고, 과도한 카리스마식 경영을 하다 결국 자신이 만든 회사에서 쫓겨나기까지 하는 수모를 겪은 그다. 이 정도 경험치로 이루어진 직관에게 시장 조사 결과가 별 건가? 전화성 대표님깨서 한 마디 하셨다. “경험치를 그 정도 쌓은 분야에서 사업을 하던가, 아니면 시간을 가지고 시장 조사를 해” 실제로 서비스를 오픈에서 시장에 뛰어들면, 수많은 예측하지 못했던 문제들이 튀어나온다. 그렇다면, 사업 시작 전에 충분히 주의해서 막을 수 있는 문제들은 막아야 하지 않을까? 치밀하고 날카롭게 사업 하자. P.S 전화성 대표님도 운동을 대단히 강조하셨다. 사업할려면 인내심이 엄청나게 필요한데 키우는 방법은 오직 운동 뿐이라고. 열심히 하자!","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"집합 자료형 다루기","slug":"set-in-python","date":"2018-09-17T15:01:29.000Z","updated":"2018-09-17T15:43:07.353Z","comments":true,"path":"2018/09/18/set-in-python/","link":"","permalink":"http://jeongwookie.github.io/2018/09/18/set-in-python/","excerpt":"","text":"집합. 고등학교 수학 시작하면 가장 처음에 나오는 개념이지. 집합 자료형은 set()을 이용하여 생성할 수 있다. 이들의 특징은 두 가지. 중복을 허용하지 않는다. 순서가 없다. 1번 특징 때문에 set()을 중복 요소를 제거하기 위해 사용하기도 한다. 2번 특징은 집합 자료형을 indexing 못하게 만든다. (집합 안의 요소를 index으로 특정하지 못한다) 123456789&gt;&gt;&gt; set_1 = set(\"Hello\")&gt;&gt;&gt; print(set_1)&#123;'e', 'H', 'l', 'o'&#125; #l이 하나 중복되어서 제거됨&gt;&gt;&gt; list_1 = list(set_1) #set_1을 list화&gt;&gt;&gt; print(list_1)['H', 'e', 'l', 'o']&gt;&gt;&gt; print(list_1[0]) #list이므로 indexing 가능H 집합 자료형을 이용하여 교집합(&amp;), 합집합(|), 차집합(-)을 구할 수 있다. 12345678910111213&gt;&gt;&gt; s1 = set([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; s2 = set([4, 5, 6, 7, 8, 9])&gt;&gt;&gt; print(s1 &amp; s2) #교집합 구하기&#123;4, 5, 6&#125;&gt;&gt;&gt; print(s1 | s2) #합집합 구하기&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;&gt;&gt;&gt; print(s1 - s2) #차집합 구하기&#123;1, 2, 3&#125;&gt;&gt;&gt; print(s2 - s1)&#123;8, 9, 7&#125; 끗!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"스타트업 팀 빌딩에 관한 생각들","slug":"team-member","date":"2018-09-16T14:46:03.000Z","updated":"2018-09-16T16:48:28.000Z","comments":true,"path":"2018/09/16/team-member/","link":"","permalink":"http://jeongwookie.github.io/2018/09/16/team-member/","excerpt":"","text":"초기 스타트업을 판단하는 기준에는 여러가지가 있다. 참신한 아이디어, 뛰어난 기술력, 풍부한 자금, 훌륭한 팀원들.. 다양한 factor 가 자신들의 사업계획서 속에 녹아 있다. 그런데, 내가 지금까지 만났던 투자자들 하나같이 입을 모아서 1번으로 생각하는 가치가 있다면, 그건 바로 팀이다.팀이 어떻게 만들어졌고, 구성원들 각각의 능력은 어떻고 등등.. 팀의 스토리를 알고 싶어한다. 왜 그러겠는가? 참신한 아이디어와 같은 것은 생각보다 뒷전이다. 심지어 어떤 유명 투자자는 이렇게 말하기도 했다. 아이디어는 솔직히 어찌 되어도 상관 없다고.. 팀만 좋으면 된다고. 조금 너무 나갔는지도 모르겠다. 하지만, 그만큼 팀 빌딩이 중요하다는 것만 알아두자. 팀 빌딩이 중요하다는 것은 알았다 치자. 그러면 좋은 팀원은 누구이고, 어떻게 만나야 하는 걸까? 친구랑은 사업하는 것 아니다! 앞서 이야기 하였듯이, 투자자들은 팀에 얽힌 이야기를 듣고 싶어한다. 이는 스타트업의 생존이 매우매우 어렵기 때문에, 풍파가 닥치더라도 함께 단단하게 헤쳐나갈 수 있는 결속력이 있는지 보는 것이다. 팀에 결속력이 없으면.. 조금만 상황이 어려워져도 서로 등을 돌리거나 헐뜯지 않겠는가? 브런치의 @goodnerds 님이 그리신 스타트업 만화를 봐도 대략 감이 온다. 또 하나 우리가 잘 아는 말이 있다. 고등학교 친구가 진짜 친구다! 음.. 이 말은 대학교나 그 이후 사회 생활 하면서 만나는 사람들은 어쩔 수 없이 조건에 얽혀서 만나게 되고, 진정으로 모두가 동일한 ‘학생’일 때 허물없이 어울리는 친구가 진짜 친구다 라는 말로 들린다. 그렇다면, 나에게 결속력이 가장 강한 친구들은 힘들 때 조건 없이 달려와주는 일명 ‘고등학교 친구’ 라는 건데, 친구랑은 사업 하는 것 아니라며? … 참 난감하다. 친구랑 사업하지 말라는 것도 이해가 간다. 인정에 기대게 되고, 냉철한 판단을 내리지 못하게 한다. 결국은 사업 망하면 친구까지 따라 잃으니, 하지 말라는 것일 거다. 하지만, 나는 개인적으로 이건 옛말 같다. 스타트업은 누구보다도 고된 여정이다. 코파운더(공동창업자, co-founder)는 신대륙으로 떠나는 배의 키를 잡고 선장실에서 열띤 토론을 해야 하는 선장과 그의 옛 동료들이다. 힘들 때 힘들다 말할 수 있고, 서로의 등을 맡길 수 있는 존재. 신뢰라는 것이 단시간에 생기는 것이 절대 아님을 우리는 모두 알고 있다.. 너무 사견을 많이 붙였나? 스타트업 팀 빌딩은 모두가 어려워 하는 주제가 맞다. 오죽하면 좋은 팀원을 만나기 위한 플랫폼 서비스가 성행하겠는가. 많은 초기 스타트업이 고민하는 문제이고, 이를 해결하기 위한 서비스인 고파운더와 같은 플랫폼들이 있다. 내가 본 팀 빌딩은 크게 두 가지 부류였다. 첫 번째는 짱짱한 사람이 사업을 진행하는데 필요한 짱짱한 사람들을 각 파트별로 모은 드림팀. 두 번째는 대부분의 대학생 창업에서 이루어지는, 마음 맞는 친구들과 팀 이루기. 둘 다 성공한 케이스들이 있고, 무엇이 더 성공에 가까운지는 알 수 없다. 그런데 첫 번째의 경우 만약 내가 대표자라면, 나부터 뛰어난 능력으로 무장해야 다른 사람들을 모을 근거가 마련된다. 그리고 대학생 및 아직 졸업하지 않은 대학원생은 솔직히 말해서 능력이 없다.. 그럼 답은 하나지 뭐. 능력이 조금씩 딸리더라도, 마음이 맞는 친구들. 그리고 거친 파도를 헤쳐나가며 서로에게 힘이 되어, 서로에게 성장의 원동력이 되는 친구들. 우리의 부족한 힘으로 만들어진 엉성한 스타트업을 끌어올리면서, 실력도 같이 끌어올리는 그림을 그려야지. 이쯤되면 너무 조건이 까다롭지 않냐고, 이래서 언제 창업 시작하느냐고 되물을지도 모르겠다. 단순한 직장 생활이 아니라, 창업은 삶 그 자체이기 때문에.. (수많은 야근 및 임금 없는 생활) 공동창업자는 결혼 배우자를 알아보는 것과 비슷하다. 쉽게 선택하지는 않겠지? 급하게 생각하지 말자. 창업, 쉬운 일 아니다. 하나 좋은 해결책이 있다. 본격적으로 창업에 나서기 전에, 학교 프로젝트이던 공모전이던 상관 없으니 무언가 노는 것 말고 일하는 걸 같이 해보자. 요즘은 창업 관련해서도 대회, 해커톤, 공모전 등 엄청 많으니까. 호흡을 한번 맞춰 보고, 일이 잘 진행된다 싶으면 지르자! 만약 사업이 잘 안되더라도, 값진 실패가 될 것이다. 다음 포스트에서는 작년 나의 실패 이야기를 해볼까 한다. 내가 가졌던 팀원에 대한 생각들과, 앞으로 어떤 사람과 함께할 것인지를.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"고민","slug":"고민","permalink":"http://jeongwookie.github.io/tags/고민/"}]},{"title":"KAIST E5 학생 창업지원 프로그램","slug":"kaist-e5-startup-18f-firstmission","date":"2018-09-15T06:19:23.000Z","updated":"2019-03-18T14:21:49.364Z","comments":true,"path":"2018/09/15/kaist-e5-startup-18f-firstmission/","link":"","permalink":"http://jeongwookie.github.io/2018/09/15/kaist-e5-startup-18f-firstmission/","excerpt":"","text":"카이스트에는 E*5 KAIST라고 학생창업지원 프로그램이 있다. 학생창업을 위한 일종의 오디션 프로그램 같은 건데, 작년에 여러 학교의 창업 프로그램을 참가해본 결과 여기가 제일 퀄리티가 높다. 학생들의 보유 기술 수준이 높고, 오시는 심사위원 분들이 교내 프로그램 수준이 아니다. 이때까지 오신 분들을 보면 퓨처플레이, 본엔젤스, 카카오벤쳐스 등.. 유수의 엑셀러레이터 기관에서 직접 오셨다. 선발은 크게 3단계로 이루어진다. 첫 번째는 적당한 서류평가 이후 단체로 1박 2일 캠프를 간다. 거기서 투자자분이 직접 강의하는 BM 모델링 수업을 듣고, 날밤을 새서 피피티를 만들고 발표한다. 이를 First Mission이라고 하는데, 발표의 초점은 어떤 좋은 Problem을 어떤 Customer가 겪는지, 그리고 고객들에게 어떤 Unique Value를 줄 수 있는지에만 맞춰져 있다. 즉, Solution은 크게 안본다는 소리. 보통의 사업계획서에 있는 마케팅 전략, 경쟁사 심층 분석, 자금 유치 계획, 개발 마일스톤 등은 물론 보긴 보지만 크게 문제삼지는 않는 분위기. 이 발표를 바탕으로 15팀까지 추리고, 2차 미션에 돌입하게 된다. Second Mission은 Customer Discovery 에 초점을 크게 둔다. 첫 번째 미션 당시 발표했던 핵심 문제와, 이 문제를 앓고 있는 고객에 대해서 실제 이 분들을 만나는 것이다. 각 팀들은 고객을 심층 인터뷰 한 결과를 바탕으로 자신들이 세운 가설을 검증하고, 그 활동들을 정리하여 투자자들을 설득할 기회를 얻게 된다. 이 때, 발표를 들은 투자자 4분이 각각 자신들의 안목을 바탕으로 ‘아 이팀은 되겠다!’ 하고 키워볼 팀을 3팀씩 선발한다. 이후, Third Mission이라고 불리는 온전한 형태의 사업계획서 완성을 자신들을 뽑은 멘토 투자자와 함께 1달 동안 진행하게 된다. 슈퍼스타k의 기분을 조금이나마 느껴볼 수 있다 최종 상금은 우승은 무려 1천만원. 사업비 아니고 프리하게 사용할 수 있는 금액이라 인건비로 사용할 수 있고, 막말로 그거 받아서 술 사먹어도 되는 만큼 자유로운 돈이다. 창업해 보신 분들은 알겠지만.. 사업비를 따 와도 마음대로 쓸 수가 없다 ㅠㅠ 항목도 고정되어 있고, 심지어 인건비로 한푼도 못쓰게 하는 명목만 있는 사업비도 많은데, 이런 상금들은 초기 스타트업이 생존하는데에 단비 같은 존재다. 여기까지가 프로그램 소개였고, 내가 지금 2018년도 가을학기 E*5 KAIST 첫 번째 미션 발표장에 와 있다.. 과기원 창업 카톡방에서 연결된 학부생들과 팀을 맺어서, 어제 처음 만나서 아이디어 회의하고 얼른 발표 자료를 만들었다 ㅋㅋ 이미 진행하고 있는 사업이 있지만, 라이트한 느낌으로 비즈니스 모델 설계를 알려주고 싶은 친구를 같이 데려와서 알려주고 오랜만에 머리 한번 맞대는 느낌 받고 싶어서 왔다. 사진은 오랜만에 만났던, 같은 학부의 친한 후배. 사업 되게 잘한다. 아는 사람들도 만나고, 밤을 새 가면서 치열하게 이야기하고 그러니까 머리가 다시 좀 깨는 느낌이다. 작년에는 진행했었던 사업 아이템으로 최종 미션까지 살아남았었는데, 이번에는 어떨까? 결과와 관계없이, 이런 자리에서 프레쉬한 아이디어를 듣는 것이 너무 즐겁다.","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"},{"name":"창업 이야기","slug":"Diary/창업-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/창업-이야기/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"KAIST 창업석사","slug":"kschool-student","date":"2018-09-14T03:49:15.000Z","updated":"2019-03-18T14:15:39.413Z","comments":true,"path":"2018/09/14/kschool-student/","link":"","permalink":"http://jeongwookie.github.io/2018/09/14/kschool-student/","excerpt":"","text":"(2019.03 추가) 19년 가을학기 카이스트 창업석사 모집에 대해 최근에 포스트를 하나 더 작성했습니다. 관심 있으신 분들은 참고해 주세요. 최근 포스트 : KAIST 창업석사 신입생 모집 (19년 가을) 내가 다니고 있는 과정에 대해서 소개하고자 한다. 나는 현재 KAIST 기술경영학부 대학원에 다니고 있는데, 특이하게도 학위 과정이 창업융합전문석사 이다. 아직 이 전형으로 입학한 학생이 겨우 5기 뿐이고, 사람들이 잘 모르는 것 같아 간략하게나마 써본다. 일명 창업석사는 국내에서는 카이스트에서 처음 시작한 교과석사로, 미국의 유수 대학들이 시행하고 있는 것을 도입한 제도이다. 18개 정도의 학과가 공동으로 운영하므로, 학사를 졸업한 학생들은 자신이 원하는 전공을 선택하고 창업융합전문석사 트랙(Track)으로 시험 및 면접을 치루게 된다. 입학 하기 전에는 기술경영학부와 같이 이름이 창업과 밀접한 연관이 있는 부서만 사람이 많을 줄 알았는데 그건 또 아니다. 전산학부, 전기전자공학부, 기계공학부 등 major 학과의 창업석사또한 많이 있었으며 심지어 순수과학 분야인 화학과 학생도 몇 있었다. 창업석사로 진학할 것인가에 대한 판단 기준이 될만한 정보들을 내 나름대로 아래에 정리했다. 첫 번째, 만약 당신이 창업을 하고 있거나, 창업을 당장 할 계획을 가지고 있다면 베스트 초이스가 아닌가 싶다. 다만 창업중인 대표 본인이 입학을 희망하는 경우, 학교 교칙 상 직장을 가지고 있는 사람은 입학할 수 없으므로 회사 내부에서 해결 후 입학하여야 한다. 그러나, 입학 후에는 자유롭기 때문에 잠시 입학 시기에 회사를 떠나있다가 돌아오는 방법도 생각해 봄 직하다. 만약 당장 창업 시기를 재고 있는 사람들은 그냥 입학 후에 곧바로 창업 하는 것이 마음 편하다. 실제로 창업석사 동기들을 보면 창업을 안한 사람이 손에 꼽을 정도이다. 모두가 다 자신이 스타트업 대표거나 코파운더 (co-founder)로써, 학교 다니면서 일도 동시에 하고 있다. 두 번째, 근미래에 창업을 꿈꾸고 있다면 그것도 좋다. 일단 KAIST 라는 우리나라에서는 최고로 알아 주는 창업 선도 대학의 울타리 안으로 들어오게 된다. 퓨처플레이, 본엔젤스, 케이큐브벤쳐스, 블루포인트파트너스 등 국내 유수의 엑셀러레이터 기관의 대표 혹은 핵심 파트너들은 전부 KAIST 출신 석박사들이다. 게다가 학교에서 가만히 앉아만 있어도 방금 언급한 엑셀러레이터, 한창 성장중인 유망 스타트업들이 좋은 인재를 영입하기 위해 찾아온다. 대표적으로 카이스트 내부 창업 경진대회인 E*5 KAIST에는 교내 대회 답지 않게 평가단이 엄청나다. 입학 시 내부 지원도 상당하다. 석사 장학금이 1년간 지급되므로 창업을 위해 서울로 왔다갔다 교통비도 쏠쏠하게 충당할 수 있다. 그리고 스타트업빌리지 를 매달 10만원에 최우선순위로 입주할 수 있다. 3인 1실이 기본인데, 카이스트 내부 기숙사 중 가장 최고의 시설을 자랑해서 창업석사생 아니면 입주가 거의 불가능하다. 카이스트 내부 창업팀으로 구성하여 숙소 겸 사무실로 쓰는 학생들도 몇 있었다. 또한, 창업에 직결되는 실전 위주의 수업들이 열린다. 지금까지 전공 과목만 공부하느라 실전에 뛰어들면 부딪힐 수 밖에 없는 디지털 마케팅, 재무 &amp; 회계 등의 기본 지식은 물론이고, 성공한 창업가들을 직접 교수님으로 모셔서 대표로써 직접 경험하셨던 재무, 마케팅, 인사 관리 등을 가르쳐 주신다. 근 미래에 창업을 꿈꾸고 있다면, 쭉 코스를 밟아서 기본 지식과 인맥을 쌓아서 나아가는 판단, 괜찮다고 본다. 입학하고 나서 처음 수강했던 창업 수업 세 번째, 평범한 대학원 연구실 생활은 맞지 않고, 무언가 다른 길을 생각하는 사람도 추천한다. 창업석사는 일반 석사와는 달리 연구실에 소속될 의무가 없다. 자신이 창업하기에 도움을 받기 위해 연구실에 소속되는 학생들도 있지만, 대부분의 창업 석사 입학생들은 연구실 없이 창업을 한다. 그리고 매 학기 지도교수님과 자신이 창업하였거나, 창업 하고 싶은 일에 대해서 같이 논의하고 필요에 의하면 같이 연구도 병행한다. 과학기술원 학부 출신들은 다 알겠지만, 대학원에 들어가면 졸업할 때 까지 창업의 ‘창’ 자도 입밖으로 못낸다.. 실제로, 몇몇 연구실에서 교수님 몰래 창업을 했다가 짤리는 경우도 보았고, 창업 수업을 (또는 부전공) 듣고 싶다고 교수님께 은근히 내비쳤더니 극대노?! 하신 교수님을 영접했다고 한다.. 그런데, 창업석사로 입학한 학생들은 그래도 이런 틀에서 조금은 벗어나 있다. 창업석사로 입학하면 애초에 창업을 하라고 뽑은 사람들이라.. 교수님들이 크게 터치하시지 않는 편이다. 자신의 전공 과목 공부 열심히 하고, 다른 대학원생들이 연구실에 가는 시간에 한번 교내 스타트업에서 일해보는 것도 창업에 대해 좀 더 알 수 있는 좋은 기회가 될 것이다. 게다가 빡빡하게 수강한다면 1년으로도 석사 과정을 끝낼 수 있다. 연구보다 취업에 관심이 있어, 빠르게 학업을 마치고 싶은 미필자에게는 단비와 같은 과정임을 알 수 있다. 창업석사는 미래부에서 정식 인정한 석사과정으로, 전문연구요원 편입 대상이 된다. 개인적으로 입학해서 얻은 것이 많아, 아직까지는 만족하면서 학교 다니고 있다. 학교에서 하는 창업 수업 + 전공 수업 + 스타트업 근무 이렇게 3 세트로 돌리는 중! 카이스트 창업석사에 대해 궁금하신 분은 언제든지 연락 환영합니다 :) 이 기사도 참고하세요!","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"학교 이야기","slug":"Diary/학교-이야기","permalink":"http://jeongwookie.github.io/categories/Diary/학교-이야기/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"},{"name":"창업석사","slug":"창업석사","permalink":"http://jeongwookie.github.io/tags/창업석사/"}]},{"title":"튜플과 딕셔너리 자료형","slug":"tuple-and-dictionary","date":"2018-09-13T16:18:27.000Z","updated":"2018-09-13T17:33:55.448Z","comments":true,"path":"2018/09/14/tuple-and-dictionary/","link":"","permalink":"http://jeongwookie.github.io/2018/09/14/tuple-and-dictionary/","excerpt":"","text":"튜플(tuple)은 리스트와 거의 유사하지만 다음과 같은 차이점이 있다. 대괄호 []가 아닌, 소괄호 ()를 사용 리스트는 요소의 변경이 가능하지만, 튜플은 변경이 불가능 (immutable) 얼핏 보면 리스트보다 튜플이 나은 점이 없어 보이는데, 왜 쓸까? 이에 대해 조교님께 물어봤는데, 튜플은 변경이 불가능하다는 속성 자체가 가치 있다고.. 즉 여러 명의 개발자가 같이 프로젝트를 진행할 경우, 어떤 요소들을 튜플로 표시했을 때 다른 개발자가 보고 ‘아 이것은 변경하지 말라는 소리구나’ 라고 이해한다고 한다. 그리고 일반적인 경우에도 값이 바뀌는 상황이 걱정될 경우, 튜플을 일부러 사용하기도 한다. 딕셔너리(dictionary) 자료형은 대응 관계를 표시한다. key와 value가 한 쌍이 되는데, 딕셔너리 자료형에서 값을 찾을 때는 index가 아닌 key로 이에 대응되는 값을 찾게 된다. 12345678&gt;&gt;&gt; dict = &#123;\"name\" : \"김정욱\", \"age\" : 26&#125;&gt;&gt;&gt; print(dict[\"name\"])김정욱&gt;&gt;&gt; print(dict[\"age\"])26&gt;&gt;&gt; dict[\"home\"] = \"Daejeon\" #딕셔너리 쌍 추가하기&gt;&gt;&gt; print(dict)&#123;\"name\" : \"김정욱\", \"age\" : 26, \"home\" : \"Daejeon\"&#125; 딕셔너리 관련 함수들이 몇 가지 있는데, 기본적인 것만 간단하게 살펴보자. 1. Key 및 Value 리스트 생성하기 (keys, values)12345678&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26&#125;&gt;&gt;&gt; print(a.keys()) #keys() 함수 사용dict_keys([\"name\", \"age\"]) #dict_keys 객체 리턴&gt;&gt;&gt; print(list(a.keys())) #list로 변환[\"name\", \"age\"]&gt;&gt;&gt; print(a.values()) #values() 함수 사용dict_values(\"김정욱\", 26) 2. Key 와 Value 쌍 생성하기 (items)123&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26&#125;&gt;&gt;&gt; print(a.items()) #items() 함수 사용dict_items([(\"name\", \"김정욱\"), (\"age\", 26)]) 3. Key 와 Value 쌍 모두 지우기 (clear)1234&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26&#125;&gt;&gt;&gt; a.clear() #clear() 함수 사용&gt;&gt;&gt; print(a)&#123;&#125; 4. Key 로 Value 얻기 (get) get(x) 함수는 x라는 key에 대응되는 value를 반환한다. 딕셔너리 자료형의 핵심이라고 보면 된다. 1234567&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26&#125;&gt;&gt;&gt; print(a.get(\"name\"))\"김정욱\"&gt;&gt;&gt; print(a.get(\"age\"))26&gt;&gt;&gt; print(a.get(\"major\")) #a에 없는 key값을 넣었을 때?!None 위 코드를 살펴보면, 현재 a라는 딕셔너리에는 key가 “name” , “age” 두 개 뿐이다. 그런데, 6번째 줄에서 “major”라는 존재하지 않는 key를 get() 함수를 이용해 지정한 경우, None을 반환한다. 이를 이용하는 대단히 휼륭한 예시가 있다. 당신에게 이름, 나이, 전공이 기록된 엑셀 파일이 있다고 하자. 하지만 이번 년도에 새로 입학하는 신입생들은 전공이 아직 없다. 위의 get() 함수를 사용하면 전공이 입력되지 않은 학생들을 “새내기”로 반환할 수 있다. 123456&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26, \"major\" : \"Business\"&#125;&gt;&gt;&gt; b = &#123;\"name\" : \"이하린\", \"age\" : 20&#125;&gt;&gt;&gt; print(a.get(\"major\", \"새내기\"))\"Business\"&gt;&gt;&gt; print(b.get(\"major\", \"새내기\"))\"새내기\" 4번째 줄은 key가 “major”인 value, “Business”를 반환하게 한다. 그러나 6번째 줄은 “major” 이라는 key가 없을 경우 “새내기” 라고 반환하게 한다. 5. 해당 Key가 딕셔너리 안에 있는지 조사하기 (in)12345&gt;&gt;&gt; a = &#123;\"name\" : \"김정욱\", \"age\" : 26, \"major\" : \"Business\"&#125;&gt;&gt;&gt; \"name\" in aTrue&gt;&gt;&gt; \"email\" in aFalse","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"Hexo 카테고리 이름 설정 시 문제","slug":"category-name-problem","date":"2018-09-12T17:01:42.000Z","updated":"2018-10-02T07:11:54.594Z","comments":true,"path":"2018/09/13/category-name-problem/","link":"","permalink":"http://jeongwookie.github.io/2018/09/13/category-name-problem/","excerpt":"","text":"새벽에 왠 고생이냐… 블로그 글을 정리하고 있는데, 갑자기 페이지 로딩이 안됐다. 짜증을 뒤로 하고, 얼른 해결책부터 찾으려고 하는데 놀라운 점을 발견했다. 카테고리 이름이 Python, Growth Hacking인 곳은 누르면 에러 발생 카테고리 이름이 Diary, Github인 곳은 문제 없이 작동 아니 이게 무슨 상황이란 말인가? 모두 다 작동이 안된다면 뭔가 directing 문제가 발생했거니와.. 헤더 파일이나 설정 파일을 볼껀데 이건 되고 저건 안되니 어이가 없더라. 페이지 관리 도구에 들어가서 페이지 에러를 확인했더니 이런 메세지가 뜬다. Refused to load the font ‘‘ because it violates the following Content Security Policy directive… “default-src ‘none’”. Note that ‘font-src’ was not explicitly set, so ‘default-src’ is used as a fallback. 뭐라고? Content Security Policy 라는 걸 어겨서 로딩이 거부되는 거라고? 처음에는 폰트가 어쩌구.. 하길래 폰트 로딩이 안됐나 하고 head.ejs 파일 살펴보고, _variables.styl 이랑 _config.yml 설정 파일 계속 들여다보고 이것 저것 고쳐봤는데 안됐다. 그런데 느낌이 쎄했다. 혹시 Security Policy라 그러니까 카테고리 이름에 hacking이 들어가서 블럭을 당한게 아닐까? 바로 “Growth Hacking” 이라는 카테고리 이름을 그로스 해킹 이라고 바꿨더니.. ###됐다?! 그렇다면 “Python”도 모종의 이유로 블럭을 당했다고 판단, 파이썬으로 고쳐 적었더니 정상 작동한다. 결론 : 카테고리 이름에 “Hacking” 이나 “Python” 을 적으면 안된다네 이유를 아시는 분은 알려주세요 ㅠㅠ","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/categories/Hexo/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://jeongwookie.github.io/tags/Github/"},{"name":"블로그 issue","slug":"블로그-issue","permalink":"http://jeongwookie.github.io/tags/블로그-issue/"},{"name":"Error","slug":"Error","permalink":"http://jeongwookie.github.io/tags/Error/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/tags/Hexo/"}]},{"title":"마시는 링거, 링티 후기","slug":"recommend-lingerwater","date":"2018-09-12T15:15:34.000Z","updated":"2018-09-16T07:00:55.000Z","comments":true,"path":"2018/09/13/recommend-lingerwater/","link":"","permalink":"http://jeongwookie.github.io/2018/09/13/recommend-lingerwater/","excerpt":"","text":"요즘따라 몸이 많이 피곤함을 느낀다. 커피를 마셔도 예전같이 빠릿빠릿하지 않고.. 격일로 운동을 간지 1달 조금 넘었는데 체력이 길러지기는 커녕 더 떨어진 것 같다. 그 와중에 와디즈를 보다가 무심코 발견한 아이템이 바로 마시는 링거, 링티 군의관들이 개발한 것이란다. 열사병으로 쓰러지는 군인들을 위해 개발했는데, 기사를 보니 군 장성들이 그렇게 좋아한단다. 좋은 건 바로 알아보는 그들이니.. 정말 괜찮을 것 같다는 생각이 ㅋㅋㅋ 분말 형태로, 간단하게 500ml 생수만 준비해서 타먹으면 끝! 공식 사이트에서 주문하려고 보니까 전용 생수통을 팔던데, 예뻐 보여서 같이 샀다. 링티 1 Box에 27,000원인데 기호식품이라고 생각하면 비싼 편이지만 아플 때 링거 맞은 것처럼 힘이 난다면 이정도 돈은 충분히 지불할 용의가 있었다. 최근에 속이 많이 아파서 정밀 검진도 받고, 밥을 제대로 먹지 못했기 때문에 링티가 더 간절하게 느껴졌다. 작업하면서 바로 타서 마셔보았다. 맛은 포카리스웨트에 레모나를 약간 탄 느낌이었다. 맛있지도, 맛없지도 않은 맛. 기분 탓인지 모르겠는데, 마시고 나니까 뭔가 너무 잠이 와서… 한숨 자고 왔다. 그런데 효과가 조금은 있다고 생각이 드는게, 오늘 밥을 아주 조금씩 먹어서 힘이 없었는데 조금씩 돌아오는 것이 느껴지더니 저녁에 운동까지 갔다와도 멀쩡하다! 아직 한번 밖에 마시지 않았지만, 첫 느낌이 좋다. 괜찮으면 부모님께도, 동생한테도 하나씩 사서 추석때 들고가야겠다. 링티 추천!! 판매 링크 : https://smartstore.naver.com/lingerwater","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"추천 아이템","slug":"Diary/추천-아이템","permalink":"http://jeongwookie.github.io/categories/Diary/추천-아이템/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"추천 아이템","slug":"추천-아이템","permalink":"http://jeongwookie.github.io/tags/추천-아이템/"}]},{"title":"리스트 자료형 다루기","slug":"list-operation","date":"2018-09-12T04:49:03.000Z","updated":"2018-09-13T06:48:25.570Z","comments":true,"path":"2018/09/12/list-operation/","link":"","permalink":"http://jeongwookie.github.io/2018/09/12/list-operation/","excerpt":"","text":"파이썬 강의 첫 날, 또 하나의 자주 쓰는 자료형을 배웠다. 리스트 (list)란 특정 값들을 순서 있게 저장하는 자료형이다. C와는 달리, 하나의 리스트 안에 숫자와 문자가 공존할 수 있더라. 앞서 배운 문자열처럼 리스트 또한 인덱싱과 슬라이싱을 할 수 있다. 하지만, 각각의 결과물에 대해 조심해야 할 필요가 있다. 123456789&gt;&gt;&gt; lst = [\"Python\",2,3,4,5]&gt;&gt;&gt; print(lst[0]) #lst의 첫번째 원소를 출력Python&gt;&gt;&gt; print(lst[1]) #lst의 두번째 원소를 출력2&gt;&gt;&gt; print(lst[1:]) #lst를 두번째 부터 끝까지 슬라이싱[2, 3, 4, 5]&gt;&gt;&gt; print(lst[0][0]) #lst의 첫번째 원소 안의 첫번째 원소P 위의 결과를 보면 특이한 점이 한 가지 보인다. 바로, 리스트를 인덱싱 한 결과값은 그 자리의 원소 (숫자)인 반면 리스트를 슬라이싱 한 결과값은 리스트로 반환되는 것이다! 리스트의 값을 수정하거나 삭제하고 싶은 경우가 있다. 문자열의 요소값을 바꿀수 없는 것과는 달리, 리스트의 값은 쉽게 바꿀 수 있다. 123456789101112&gt;&gt;&gt; a=[1,2,3,4,5]&gt;&gt;&gt; print(a)[1, 2, 3, 4, 5]&gt;&gt;&gt; a[0] = 100&gt;&gt;&gt; a[4] = \"Python\"&gt;&gt;&gt; print(a)[100, 2, 3, 4, Python]&gt;&gt;&gt; del a[0] #a의 첫번째 원소 삭제&gt;&gt;&gt; print(a)[2, 3, 4, Python] 위의 예시를 보면 알겠지만, 리스트의 요소값을 삭제하고 싶은 경우 del 함수를 사용하여 정확히 인덱싱 한 부분을 삭제할 수 있다. 리스트 또한 문자열과 마찬가지로 변수명 뒤에 ‘.’을 붙여서 관련 함수들을 사용할 수 있다. 자주 쓰이는 함수 몇 가지만 알아보자. 1. 요소 추가하기 (append) .append(x)는 리스트의 맨 마지막에 x를 추가시키는 함수이다.1234&gt;&gt;&gt; fruits = ['apple', 'banana', 'cherry']&gt;&gt;&gt; fruits.append(\"orange\")&gt;&gt;&gt; print(fruits)['apple', 'banana', 'cherry', 'orange'] append()를 사용할 경우 원본 data가 변형된다는 점에 주의해야 한다. 2. 리스트 정렬하기 (sort) .sort()는 리스트의 요소를 순서대로 정렬해 주는 함수이다.12345678&gt;&gt;&gt; a = [1, 4, 3, 2]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; print(a)[1, 2, 3, 4]&gt;&gt;&gt; a.sort(reverse=True)&gt;&gt;&gt; print(a)[4, 3, 2, 1] 문자가 요소인 리스트의 경우, 기본적으로 제일 첫 글자의 순서대로 정렬해 준다. key값을 지정해 줌으로써 정렬 기준을 바꿀 수 있다. 12345678# A function that returns the length of the value:&gt;&gt;&gt; def myFunc(e): return len(e)&gt;&gt;&gt; cars = ['Ford', 'Mitsubishi', 'BMW', 'VW']&gt;&gt;&gt; cars.sort(key=myFunc)&gt;&gt;&gt; print(cars)['VW', 'BMW', 'Ford', 'Mitsubishi'] 3. 리스트 순서 뒤집기 (reverse) .reverse()는 리스트를 역순으로 뒤집는 함수이다.1234&gt;&gt;&gt; a = ['a', 'c', 'b']&gt;&gt;&gt; a.reverse()&gt;&gt;&gt; print(a)['b', 'c', 'a'] 4. 요소 끄집어내기 (pop) .pop(x)은 리스트의 x번째 요소를 반환하고 해당 요소는 리스트에서 삭제하는 함수이다. 주로 index로 요소를 찾고, 그 값을 반환하고 리스트에서 삭제를 원할 경우 사용한다. index로 요소를 찾고 단순히 제거를 원할 경우 del을 사용하고,index가 아닌 그 값으로 요소를 찾고 제거를 원할 경우 remove()를 사용한다. 후자의 경우 입력한 값이 리스트에 없는 경우 ValueError가 발생한다. 12345678910&gt;&gt;&gt; fruits = ['apple', 'banana', 'cherry']&gt;&gt;&gt; fruits.pop(1)&gt;&gt;&gt; print(fruits)['apple', 'cherry']&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; print(a.pop()) #index을 지정하지 않은 경우3 #리스트의 맨 마지막 요소를 반환&gt;&gt;&gt; print(a)[1, 2] 위에서 소개하지 않은 나머지 리스트와 관련된 함수들은 여기를 참고하면 된다. 특히 .append() 와 .pop() 은 자주 쓰이는 함수이다. 예를 들어 data stream을 append()를 이용해서 차례대로 받고, pop()을 통해서 제일 뒤부터 차례대로 뽑아서 처리하는 식으로 쓴다고 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"Format 함수로 정렬하기","slug":"code-alignment-using-format-function","date":"2018-09-11T14:38:47.000Z","updated":"2018-09-13T06:47:49.596Z","comments":true,"path":"2018/09/11/code-alignment-using-format-function/","link":"","permalink":"http://jeongwookie.github.io/2018/09/11/code-alignment-using-format-function/","excerpt":"","text":"첫 번째 시간에 배운 Format 함수로 정렬(Alignment)을 할 수 있다. 주로 출력물을 보기 좋게 정렬하고 싶을 때 많이 사용한다고 한다. Code Feature {:k&gt;10} 10칸 공간, 오른쪽 정렬, 공백을 k로 채우기 {:k&lt;10} 10칸 공간, 왼쪽 정렬, 공백을 k로 채우기 {:k^10} 10칸 공간, 가운데 정렬, 공백을 k로 채우기 아래의 예시 코드를 보자. 1234567891011# 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 왼쪽 정렬&gt;&gt;&gt; print(\"&#123;:&lt;10&#125; Jeongwook\".format(\"Hi\"))Hi Jeongwook# 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 오른쪽 정렬&gt;&gt;&gt; print(\"&#123;:&gt;10&#125; Jeongwook\".format(\"Hi\")) Hi Jeongwook# 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 가운데 정렬&gt;&gt;&gt; print(\"&#123;:^10&#125; Jeongwook\".format(\"Hi\")) Hi Jeongwook &lt;는 왼쪽 정렬, &gt;은 오른쪽 정렬, ^은 가운데 정렬임을 기억하자. 콜론(:) 바로 뒤에 채우고 싶은 문자나 숫자를 입력하면 된다. 아래와 같이 print 함수로 출력할때 예쁘게 구분하기 위해 사용한다. 123# 20칸 공간, 5칸에 Hello 넣고 나머지는 =으로 채움, 가운데 정렬&gt;&gt;&gt; print(\"&#123;:=^20&#125;\".format(\"Hello\"))=======Hello========","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"첫번째 숙제","slug":"First-homework-python","date":"2018-09-11T08:27:10.000Z","updated":"2018-09-13T06:48:19.395Z","comments":true,"path":"2018/09/11/First-homework-python/","link":"","permalink":"http://jeongwookie.github.io/2018/09/11/First-homework-python/","excerpt":"","text":"1번 문제 : 슬라이싱 및 문자열 합치기 첫 번째 문제는 주어진 string을 “슬라이싱” 및 “문자열 합치기”를 사용해서 주어진 format으로 만드는 것이다. “20180108”을 “2018년 01월 08일”로 바꾸어 출력해 보자. 12345678&gt;&gt;&gt; a = \"20180108\"&gt;&gt;&gt; year = a[:4]&gt;&gt;&gt; month = a[4:6]&gt;&gt;&gt; date = a[6:]&gt;&gt;&gt; date_format = \"&#123;&#125;년 &#123;&#125;월 &#123;&#125;일\"&gt;&gt;&gt; print(date_format.format(year, month, date))2018년 01월 08일 2번 문제 : 나누기 및 나머지 구하기를 활용한 1번 문제 풀이 두 번째 문제는 1번 문제와 동일한 결과물을 “나누기” 및 “나머지 구하기”를 활용하여 출력하는 것이다. 1234567&gt;&gt;&gt; a = 20180108&gt;&gt;&gt; year = int(a/10000) #int로 정수화&gt;&gt;&gt; month = int((a%10000)/100) #int로 정수화&gt;&gt;&gt; date = (a%10000)%100&gt;&gt;&gt; print(\"&#123;0&#125;년 &#123;3&#125;&#123;1&#125;월 &#123;3&#125;&#123;2&#125;일\".format(year, month, date, 0))2018년 01월 08일 다른 방법도 있을텐데 그냥 0 자리를 만들고 그대로 format 함수 사용해서 채워넣었다. 3번 문제 : 슬라이싱 및 문자열 합치기 세 번째 문제는 주어진 문자열의 문자를 “슬라이싱” 및 “문자열 합치기”를 활용하여 바꾸는 것이다. “Hi Jeongwook” 을 “Hello Jeongwook” 으로 바꾸어 보자. 123456&gt;&gt;&gt; b = \"Hi Jeongwook\"&gt;&gt;&gt; say_hello = \"Hello \"&gt;&gt;&gt; result_statement = say_hello + b[3:]&gt;&gt;&gt; print(result_statement)\"Hello Jeongwook\" 4번 문제 : 원하는 문자를 Upper letter로 바꾸어 보기 네 번째 문제는 문자열을 입력 받은 후 첫 번째 문자와 마지막 문자만 대문자로 바꾸어 출력하는 것이다. 입력 받은 문자열을 슬라이싱 후 원하는 부분만 upper()을 적용한 후 다시 합치면 된다. 1234567&gt;&gt;&gt; input_statement = input()&gt;&gt;&gt; first_letter = input_statement[0].upper()&gt;&gt;&gt; last_letter = input_statement[-1].upper()&gt;&gt;&gt; middle_letter = input_statement[1:-1].lower()&gt;&gt;&gt; output_statement = first_letter + middle_letter + last_letter&gt;&gt;&gt; print(output_statement)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"문자열 자료형 다루기","slug":"Common-string-operation","date":"2018-09-10T14:30:06.000Z","updated":"2018-09-13T06:48:13.268Z","comments":true,"path":"2018/09/10/Common-string-operation/","link":"","permalink":"http://jeongwookie.github.io/2018/09/10/Common-string-operation/","excerpt":"","text":"첫번째 강의 시간에 배운 내용 중 주목해야 할 점은 format의 쓰임이었다. 예전에 C로 코딩할때는 %d, %f 등을 잘 찍어줘야 하는데, 파이썬은 그런게 없어도 잘되네? 기본적인 포맷은 아래와 같다. 1'&#123;&#125; &#123;&#125;'.format('one', 'two') 이렇게 치면 결과값이 “one two”로 나온다. (string) 내가 앞에서 순서를 지정할 수도 있다. 1'&#123;1&#125; &#123;0&#125;'.format('one', 'two') 결과값은 “two one” 이다. 자세한 내용은 PyFormat에서 확인할 수 있다. 이외에도 주로 문자열 자료형에 대해서 다루었다. 내용을 간단히 열거하면 아래와 같다. 문자열 더하기 및 곱하기1234&gt;&gt;&gt; a = \"I love \"&gt;&gt;&gt; b = \"Python!\"&gt;&gt;&gt; print(a+b)\"I love Python!\" 123456&gt;&gt;&gt; print(\"=\" * 20)&gt;&gt;&gt; print(\"Python is god\")&gt;&gt;&gt; print(\"=\" * 20)====================\"Python is god\"==================== 문자열 인덱싱 문자열 인덱싱이란, 말그대로 문자열에서 문자들에게 순서를 숫자로 매기는(indexing) 것이다.“파이썬은 0부터 숫자를 센다” 라는 사실만 주의하자.1234567&gt;&gt;&gt; string = \"Python\"&gt;&gt;&gt; string[0]'P'&gt;&gt;&gt; string[3]'h'&gt;&gt;&gt; string[-1]'n' 문자열 슬라이싱 문자열 슬라이싱이란, 주어진 문자열을 자르는 (slicing) 것이다. 내가 원하는 만큼 범위를 지정하면 딱 그만큼 잘라서 준다. 단, 범위를 지정할 때 끝은 포함하지 않음에 주의하자.1234567&gt;&gt;&gt; string = \"Python is king\"&gt;&gt;&gt; string[0:7]'Python'&gt;&gt;&gt; string[7:]' is king'&gt;&gt;&gt; string[:]'Python is king' 문자열 슬라이싱은 주어진 문자열을 수정하고 싶을 때 유용하게 사용할 수 있다.문자열의 요소값은 바꿀 수 있는 값이 아니기 때문에 (immutable: 불변의) 문자열 슬라이싱 후 더하는 방법을 사용한다.12345678# 예시: \"Pithon\" 을 \"Python\"으로 바꾸고 싶다!&gt;&gt;&gt; a = \"Pithon\"&gt;&gt;&gt; a[:1]'P'&gt;&gt;&gt; a[2:]'thon'&gt;&gt;&gt; a[:1] + 'y' + a[2:]'Python' 문자열 관련 함수들 자주 쓰이는 함수는, find (인덱스 알려주기) strip (공백 지우기) replace (문자열 바꾸기) split (문자열 나누기) 등이 있다. 자세한 내용은 점프투 파이썬 위키를 참고하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"Hexo 블로그에 이미지 업로드하기","slug":"Github-Blog-image-upload","date":"2018-09-10T13:46:48.000Z","updated":"2018-10-02T05:22:03.123Z","comments":true,"path":"2018/09/10/Github-Blog-image-upload/","link":"","permalink":"http://jeongwookie.github.io/2018/09/10/Github-Blog-image-upload/","excerpt":"","text":"Github를 사용해서 블로그를 시작하려는데, 문제가 생겼다. 왜 이미지 업로드가 안되지? 분명히 source를 확인하고, deploy_git에 정상적으로 image가 업로드 되었음에도, 내 페이지는 그대로.. 이것저것 해보다가 다시 블로그를 새로고침했더니, 정상적으로 image가 올라가 있었다 -_- 내 짧은 지식과 검색으로 다음과 같은 결론을 얻었다. Github를 이용해서 블로그를 호스팅할 경우, 전송 속도가 매우 느려서 업로드 되는데 시간이 좀 걸린다. (약 3~4분) 되긴 되지만 답답하다. 다른 방법 없나? 구글링을 열심히 해보니, 놀랍게도 GitHub Help에서 issue로 등록해 놨더라. File attachments on issues and pull requests 위에 나와있는 움짤처럼 이미지를 끌어다가 네모에 넣고 기다리면, 이미지 링크가 생긴다. 이를 원하는 페이지에 붙여넣으면 끝!","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/categories/Hexo/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://jeongwookie.github.io/tags/Github/"},{"name":"블로그 issue","slug":"블로그-issue","permalink":"http://jeongwookie.github.io/tags/블로그-issue/"},{"name":"Error","slug":"Error","permalink":"http://jeongwookie.github.io/tags/Error/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jeongwookie.github.io/tags/Hexo/"}]},{"title":"파이썬 시작하기","slug":"Start-learning-python","date":"2018-09-10T12:47:29.000Z","updated":"2018-09-13T06:51:05.900Z","comments":true,"path":"2018/09/10/Start-learning-python/","link":"","permalink":"http://jeongwookie.github.io/2018/09/10/Start-learning-python/","excerpt":"","text":"학교에서 주말마다 하는 IT 교육과정이 있다. 예전부터 파이썬을 혼자서 해보겠다고 책도 빌리고, 코드아카데미에서 몇번 끄젹여 봤었는데 시간이 잘 안나기도 하고 막상 시간이 나면 안했다.. 학부때 잠깐 EECS의 데이터마이닝 랩에서 근무 했었는데, 그때는 R을 써서 데이터를 읽어오고 간단하게 ANNOVAR 돌려보고 그랬다. C에 비해서는 대단히 직관적인 언어여서 금방금방 따라하긴 했는데 지금은 어떨까? 파이썬과 R이 Data Science 하면 제일 많이 떠오르는 언어라고 하는데, 예전보다 파이썬의 위상이 하늘을 찌를 정도로 올라가서.. 이제는 파이썬이 아무튼 대세다. 개인적으로 개발에 관심을 두기 전에도 대단히 잡다한 지식을 모으는 데에 관심이 있어서, 학부에서 화학을 전공하면서도 현대대수학과 같은 수학과 과목이랑, 양자역학, 세포생물학 및 세포물리학 등등 여기저기 돌아다녔다. 인문 수업들도 꽤나 들었고, 다양한 과목들을 수강하면서 놀라웠던 점은 하나의 현상을 보고, 이를 분석하는 방법이 너무너무 달랐다는 것이다. 예를 들어서, 수소의 오비탈을 수식으로 풀어내는 과정에 있어서 양자역학을 배울 때에는 수학적인 정의와 함께 수식 자체를 유도하는 데에 집중한 반면, 물리화학 및 양자화학에서는 적당히 하다 건너뛰고 오히려 수소 뒤의 헬륨, 리튬 등 다른 원소에 적용하고 해석하는 데에 지면을 더 할애하고 있었다. (내 성적을 보자면 양자역학과 같은 쪽이 더 취향에 맞는걸로..) 세포물리학은 더 놀라웠다. 생물 수업때 배운 시냅스의 구조 및 작용 원리에 대해서 물리학으로 접근해서, 운동방정식을 세우고 디멘션을 쪼개서 입자의 운동으로 설명하고 있었다. 여기서 약간의 insight를 얻었다. Data Science는 결국 주어진 데이터 뭉치에서 어떤 특정한 factor에 집중해서 남들이 보지 못한 문맥 속 이야기 를 끌어내는 것이 아닌가? 내가 가진 다양한 시각으로 데이터를 분석해서, 비즈니스의 혁신을 일으키고 싶은 것이 내 목표다. 그러기 위해서는 기본적인 개발 언어를 하나 제대로 익혀야겠지? 주중에는 학교 수업이랑 회사 일때문에 많이 바쁘다. 그와중에 매주 주말 6시간짜리 코스를 신청하다니.. 이젠 죽었다 ㅠㅠ 한번 열심히 해봐야지!","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jeongwookie.github.io/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jeongwookie.github.io/categories/Programming/Python/"}],"tags":[{"name":"교육","slug":"교육","permalink":"http://jeongwookie.github.io/tags/교육/"},{"name":"개발","slug":"개발","permalink":"http://jeongwookie.github.io/tags/개발/"},{"name":"KAIST IT 프로그램","slug":"KAIST-IT-프로그램","permalink":"http://jeongwookie.github.io/tags/KAIST-IT-프로그램/"},{"name":"파이썬","slug":"파이썬","permalink":"http://jeongwookie.github.io/tags/파이썬/"}]},{"title":"새 학기 시작","slug":"new-semester-start","date":"2018-08-28T04:00:38.000Z","updated":"2018-09-13T06:53:21.977Z","comments":true,"path":"2018/08/28/new-semester-start/","link":"","permalink":"http://jeongwookie.github.io/2018/08/28/new-semester-start/","excerpt":"","text":"남들보다 1주 정도 일찍 개강했습니다. 저번 학기에 블로그도 한번 열심히 해보자고 다짐했는데, 막상 학기가 바빠지고 일도 많아지다 보니 자연스럽게 관리가 안되더군요.. 이번에는 포스트 욕심을 많이 안내고 쉬는시간에 틈틈히 하나의 취미로 블로그를 관리하기로 마음 먹었습니다. 그리고 이번 학기부터 Google Analytics를 적용할 실습 공간이 필요한데, 이 블로그를 잘 관리하면 나중에는 적용할 만큼 커지지 않을까 하는 작은 바램이..ㅋㅋ 주로 학교에서 배운 것들이나 경험한 것들 위주로 포스트를 작성할 예정입니다. 또, 블로그를 Wordpress에서 GitHub를 사용한 Hexo로 옮겼습니다. 여러모로 셋팅전을 지글지글 굽고 있지만 시간이 해결해 줄것이라 생각하고.. 일단 글부터 적겠습니다! MarkDown 문법에 얼른 익숙해져야겠고, 여러가지 Plugin도 적용이 아직 미숙하여 제대로 작동하지 않을 수도 있습니다 ㅠㅠ 연락은 언제나 환영입니다 :)","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"}]},{"title":"그로스 해커의 사고 방식","slug":"How-to-growth-hacking","date":"2018-03-31T16:09:18.000Z","updated":"2018-09-13T06:49:45.152Z","comments":true,"path":"2018/04/01/How-to-growth-hacking/","link":"","permalink":"http://jeongwookie.github.io/2018/04/01/How-to-growth-hacking/","excerpt":"","text":"구체적인 그로스 해킹 방법을 알아보기 전, 그로스 해커들이 가진 사고 방식을 이해할 필요가 있다. 그로스 해커가 생각하는 방식은, 어떻게 돈을 써야 가장 효과적인 한 방을 딱 맞는 사람에게 날릴 수 있는가? 이다. 그로스 해커라는 용어를 만든 Sean Ellis는 소비자의 인식에 신경 쓰는 전통적인 방식에서 벗어나 소비자를 확보하는 것에 집중하라고 조언한다. 우리 서비스의 고객은 데리고 와야 하는 존재이다. 좋은 아이디어로는 충분치 않다. 우리의 고객은 “확보되어야만” 하는 것이고, 성대한 잔치를 열어서 짠! 보여주는 기존의 서비스 오픈 방식은 적합하지 않다. 딱 맞는 사람들이 모여 있는 딱 맞는 장소를 조준 사격하는 것이 바로 그로스 해킹의 기본이다. 기존의 마케팅은 event를 정기적으로 열어 서비스 홍보를 하는 데에 주력하였다면, 우리는 그 사이클이 목표가 아니다. 딱 한번만 하면 된다. 최초의 고객이 유입되면, 그 후 우리가 해야할 것은 또 다른 고객 유형을 찾아 유입시키는 것이 아닌, 유입된 그들을 우리 편으로 만들어 “스스로 작동하는 마케팅 기계”로 만드는 것이다. 스타트업은 그로스 엔진을 달아야 한다.","categories":[{"name":"Marketing","slug":"Marketing","permalink":"http://jeongwookie.github.io/categories/Marketing/"},{"name":"Growth Hacking","slug":"Marketing/Growth-Hacking","permalink":"http://jeongwookie.github.io/categories/Marketing/Growth-Hacking/"}],"tags":[{"name":"그로스 해킹","slug":"그로스-해킹","permalink":"http://jeongwookie.github.io/tags/그로스-해킹/"},{"name":"디지털 마케팅","slug":"디지털-마케팅","permalink":"http://jeongwookie.github.io/tags/디지털-마케팅/"},{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"}]},{"title":"나의 취미","slug":"my-hobby","date":"2018-03-31T12:24:33.000Z","updated":"2018-09-12T15:49:28.848Z","comments":true,"path":"2018/03/31/my-hobby/","link":"","permalink":"http://jeongwookie.github.io/2018/03/31/my-hobby/","excerpt":"","text":"어떻게 하면 좋은 취미를 찾을 수 있을까? 재미만 있는 것이 아니라, 무언가 도움이 되는 지속가능한 취미를 가지고 싶다. 주중에 계속 일을 하며 학교도 다니고 있으니 시간이 많이 촉박하다. 그러나 주말에 조금 쉬는 시간을 가져도 막상 그 시간이 닥치면 할 것이 마땅찮다. 그래서 늦잠을 자다가 툴툴대며 카페 와서 다시 일을 하거나.. 책을 읽는다. 이 생활도 나쁘다고는 할 수 없지만, 주중에 받는 스트레스를 상쇄할 수가 없어서 계속 쌓이는 것 같은 느낌이다. 나 자신에 대해 어떻게 보상을 해야 할지 모르겠다. 원래 내가 좋아하고, 지금도 하고 있는 취미를 적어보면 게임 독서 ??? 뭐 적을게 없네… 게임도 나는 RPG 매니아인데, 더이상 할 게임이 없고 앞으로도 할만할 게임이 나올 것 같지 않다 ㅠㅠ (살려줘요) 하스스톤이나 오버워치도 하는데, 할때마다 스트레스가 더 쌓여서 주객전도가 된다. 운동. 하고 싶기도 하고 귀찮기도 하고, 무엇보다 헬스는 재미가 떨어진다. 계속 책만 보고 싶지도 않은데… 개발 공부도 하고 이것 저것 쌓아야 할 지식들은 많지만 학교와 회사 일을 다 하고 나면 의욕이 팍 떨어진다. 작년에 그렇게 바쁜 와중에서도 나를 버티게 하는 힘이 무엇이었나 생각해보면, 그냥 많은 사람들 앞에서 내 아이디어를 발표하고 공감을 이끌어내는 활동 자체가 너무 좋았던 것 같다. 그래서 내 취미는 어떡하지..? ㅋㅋ","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"고민","slug":"고민","permalink":"http://jeongwookie.github.io/tags/고민/"}]},{"title":"소비자로부터 출발하여 거꾸로 일하기","slug":"start-from-customer","date":"2018-03-29T14:45:33.000Z","updated":"2018-09-13T06:50:14.735Z","comments":true,"path":"2018/03/29/start-from-customer/","link":"","permalink":"http://jeongwookie.github.io/2018/03/29/start-from-customer/","excerpt":"","text":"신제품 개발 프로세스에서 아마존 (Amazon)은 새로운 접근법을 고안했다. 아마존의 임원인 Ian McAllister은 이를 소비자로부터 출발하여 거꾸로 일하기 (Working backwards from the customer) 라고 부른다. 먼저 새로운 계획을 세울 때, 내부에서는 이 잠재적인 프로젝트를 마치 막 끝낸 것처럼 공표하는 것으로 시작한다. 이것은 고객들에게도 전달되어, 새롭게 제공하는 기능이 고객들이 가지고 있던 문제를 얼마나 흥미진진하고 설득력 있는 방법으로 해결하는지 설명한다. 만약 공표한 내용이 실현되지 못하면 실현할 수 있을 때까지 초기 계획을 계속해서 수정한다. 이러한 프로세스는 팀이 신제품의 역량이 어디에 있어야 하는지, 특별한 장점이 무엇인지에 대해 정확히 집중할 수 있도록 한다. 이를 내가 현재 생각하는 분야의 사업에 대해 똑같은 프레임워크로 접근해 보자. 우리가 A라는 기능을 가진 App을 만들기로 계획한다고 하자. 우리는 A가 기존의 고객들이 가지고 있는 문제를 얼마나 흥미진진하고 설득력 있는 방법으로 해결할 수 있는지 설명할 수 있어야 할 것이다. 하지만, 설명만 할 수 있다고 해서 A가 정말 좋은 기능이라고 말하기에는 어렵지 않은가? 이론적으로 이해는 하지만, 실제 프로젝트 수행에 있어 얼마나 도움이 되는지는 잘 모르겠다.","categories":[{"name":"Marketing","slug":"Marketing","permalink":"http://jeongwookie.github.io/categories/Marketing/"},{"name":"Growth Hacking","slug":"Marketing/Growth-Hacking","permalink":"http://jeongwookie.github.io/categories/Marketing/Growth-Hacking/"}],"tags":[{"name":"그로스 해킹","slug":"그로스-해킹","permalink":"http://jeongwookie.github.io/tags/그로스-해킹/"},{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"}]},{"title":"그로스 해커란?","slug":"What-is-growth-hacker","date":"2018-03-29T04:30:17.000Z","updated":"2018-09-13T06:50:20.967Z","comments":true,"path":"2018/03/29/What-is-growth-hacker/","link":"","permalink":"http://jeongwookie.github.io/2018/03/29/What-is-growth-hacker/","excerpt":"","text":"나는 틈틈이 라이언 홀리데이가 지은 ‘그로스 해킹’ 이라는 책을 읽고 있다. 이 책에 따르면 그로스 해커란, 전통적인 마케팅 표본을 버리고 검증 가능하고 추적 가능한, 그리고 확장 가능한 데이터를 바탕으로 회사의 급속 성장을 도모하는 사람이다. 전통적인 마케터가 제품을 놓고 누구에게, 어떻게 팔 것인지 고민하였다면, 그로스 해커가 하는 일은 ‘누구’와 ‘어디’ 보다는 과학적으로 더 다양하고 측정 가능한 방법에 집중하는 것이다. 예를 들어 전통적인 마케터가 회사의 브랜딩 (Branding)에 집중하였다면, 그로스 해커는 지표와 ROI (투자 대비 수익 효율, Return On Investment)를 기반으로 사고한다. 모든 그로스 해커의 궁극적인 목표는 자동으로, 영구히 지속되는 마케팅 기계를 만드는 것이다. 그로스 해킹은 도구라 하기 보다는 사고방식이다. – Aaron Ginn 최악의 마케팅 의사 결정은 바로 “아무도 원하지 않거나 필요로 하지 않는 제품을 가지고 시작하는 것”이다. 이를 그로스 해커는 정면으로 부정한다. 명백하게 잘못된 접근을 철저하게 배제한다. 이들은 맨 처음 마주하는 사람에게서 아이디어에 대한 폭발적인 반응을 이끌어 내지 못하면 제품, 넓게는 전체 사업이나 비즈니스 모델까지 전부 바뀔 수 있다고 생각한다. 전통적인 마케터는 시장의 반응이 그리 좋지 않을 때, 언제 원점으로 돌아가야 하는지에 대해서 제대로 고민한 적이 없다. 이런 생각 자체가 허용되지 않았으며 잘못된 제품 뒤에서 열심히 일할 뿐이었다. 에어비엔비 (AirBnB)는 2007년, 마루 위에 에어메트리스를 놓고 숙박하는 손님들에게 직접 만든 아침 식사를 대접하는 사업으로 시작했다. 이러한 가치 제안 (Value Proposition)은 나쁘지 않았지만, 특별하지 않은 평범한 것이었다. 하지만 창업자들은 이보다 더 많은 것을 원했다. 원점에서부터 다시 출발한 그들은, 유명한 디자인 컨퍼런스 기간에 호텔이 다 차서 방을 구할 수 없을 때 대안으로 제시하는 숙박 서비스로 자신들을 재정의했다. 이것은 초기에 잡은 시장보다는 명백히 낫다는 것이 증명되었는데, 여기서 그들은 아이디어의 확장성을 찾았다. 마침내 에어비엔비는 타겟을 약간 피벗 (Pivot)하여 호텔은 싫지만 그렇다고 호스텔이나 비좁은 방에서 고생하기는 싫은 여행객들을 사업 타깃으로 잡았다. 그리고 아침식사 제공이나 네트워킹 파트를 그들의 사업 영역에서 없앴다. 또한, 상상 가능한 모든 종류의 숙박 시설을 빌리고 예약하는 서비스로 자신들을 재정의했다. 우리가 현재 알고 있는 에어비엔비의 탄생이다. 그들이 첫번째 단계나 두번째 단계에서, 어떻게 하면 기존 서비스에 맞는 고객을 찾고 어떻게 팔지 고민하면서 작은 사업들을 붙여나가는 방법을 취할 수도 있었을 것이다. 하지만 그들은 원점에서부터 변화시키는 생각을 주저하지 않았다. 피봇은 그들이 할 수 있던 마케팅 의사 결정 중 최고였다. 그로스 해커는 프로그래머이자 마케터로써, 제품의 설계부터 고객 경험까지 모든 사이클에 대해 계획적으로 접근하고, 데이터를 수집하며, 이를 통한 전체적 의사결정을 하여 회사의 성장 (Growth)을 해킹 (Hacking)하는 사람이라고 이해가 된다.","categories":[{"name":"Marketing","slug":"Marketing","permalink":"http://jeongwookie.github.io/categories/Marketing/"},{"name":"Growth Hacking","slug":"Marketing/Growth-Hacking","permalink":"http://jeongwookie.github.io/categories/Marketing/Growth-Hacking/"}],"tags":[{"name":"그로스 해킹","slug":"그로스-해킹","permalink":"http://jeongwookie.github.io/tags/그로스-해킹/"},{"name":"디지털 마케팅","slug":"디지털-마케팅","permalink":"http://jeongwookie.github.io/tags/디지털-마케팅/"},{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"}]},{"title":"중요한 미팅을 다녀와서","slug":"after-meeting-1","date":"2018-03-27T13:10:11.000Z","updated":"2018-09-12T16:53:15.076Z","comments":true,"path":"2018/03/27/after-meeting-1/","link":"","permalink":"http://jeongwookie.github.io/2018/03/27/after-meeting-1/","excerpt":"","text":"어제는 밤을 꼬박 새고 아침 일찍 강남에 도착했다. 11시 선릉 미팅에 점심 식사 하고, 4시에 을지로 미팅, 그리고 저녁 7시까지 대전 복귀해서 수업 들어가는 매우 강행군 스케줄;; 그래도 오랜만에 움직이는 거라 정신 바짝 차리고 임했다. 여러 가지 이슈가 새로 생겨서 앞으로 더 바빠질 것 같다. 나름 깨달은 사실이 있다면, 내가 여러 사람 앞에서 피칭하는 것은 자신이 있어도 1:1로 설명은 잘 못한다는 것 짧게 보고해야 하는 자리인데도 미괄식으로 자꾸 말을 한다는 것 두 가지 모두 앞으로 고쳐나가야겠다…","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"스타트업","slug":"스타트업","permalink":"http://jeongwookie.github.io/tags/스타트업/"},{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"미팅","slug":"미팅","permalink":"http://jeongwookie.github.io/tags/미팅/"}]},{"title":"시작","slug":"Start","date":"2018-03-24T15:17:27.000Z","updated":"2018-09-13T06:53:35.097Z","comments":true,"path":"2018/03/25/Start/","link":"","permalink":"http://jeongwookie.github.io/2018/03/25/Start/","excerpt":"","text":"미루고 미루던 블로그를 이제서야 시작하기로 마음먹었습니다. 벌써 카이스트에 입학한지 1달이 지났는데 이제서야 움직이네요. 2017년은 제가 평생 기억해야 할 해입니다. 하지만 기록으로 남기지 않았더니, 점점 기억이 옅어지더라구요. 앞으로의 여정을 위해서, 꼭 기록을 남겨야겠다는 생각이 들었습니다. 편하게 제가 쓰고 싶은 주제들로 이곳을 채워나갈 계획입니다. 이야기를 나누실 분들은 언제나 환영입니다 :) Jeongwook, Kim","categories":[{"name":"Diary","slug":"Diary","permalink":"http://jeongwookie.github.io/categories/Diary/"},{"name":"일기장","slug":"Diary/일기장","permalink":"http://jeongwookie.github.io/categories/Diary/일기장/"}],"tags":[{"name":"일상","slug":"일상","permalink":"http://jeongwookie.github.io/tags/일상/"},{"name":"학교","slug":"학교","permalink":"http://jeongwookie.github.io/tags/학교/"}]}]}